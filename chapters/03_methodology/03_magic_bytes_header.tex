\section{Magic Bytes}
\label{methodology:file_components:magic_bytes}

The magic bytes section comprises the first eight bytes of the file:
\todo{check detail again}
\begin{itemize}
  \item The first four bytes contain the ASCII sequence 'FCB\\0' (0x46 0x43 0x42 0x00) serving as an immediate identifier
  \item The remaining four bytes follow a pattern similar to FlatGeoBuf \citep{flatgeobuf}, with byte 5-6 containing major version (currently 01), followed by ASCII 'FB' (0x46 0x42), and byte 8 containing patch version (currently 00)
\end{itemize}

This signature design enables applications to validate file type and version compatibility without parsing the entire header content.

\section{Header Section}
\label{methodology:file_components:header}

The header section encapsulates metadata essential for interpreting the file contents, implemented as a size-prefixed FlatBuffers-serialised \texttt{Header} table. The header serves a dual purpose: it maintains compatibility with CityJSON by encoding the equivalent of the first line of a CityJSONSeq stream \citep{ledoux_2024}—which contains the root CityJSON object with metadata, coordinate reference system, and transformations—while adding FlatCityBuf-specific extensions for optimised retrieval and indexing. The full schema definition for the header can be found in \autoref{appendix:flatcitybuf_schema}.

In a CityJSONSeq file, the first line contains a valid CityJSON object with empty \texttt{CityObjects} and \texttt{vertices} arrays but with essential global properties like \texttt{transform}, \texttt{metadata}, and \texttt{version}. The FlatCityBuf header encodes these same properties alongside additional indexing information required for cloud-optimised access patterns.

\subsection{CityJSON Metadata Fields}
\label{methodology:header:cityjson_fields}

Here are the core header fields with their data types and significance:

\begin{itemize}
  \item \textbf{version} - \textit{string (required)} - CityJSON version identifier (\eg, "2.1"), required field from CityJSON specification \citep{cityjson_spec}

  \item \textbf{transform} - \textit{Transform struct} - Contains scale and translation vectors enabling efficient storage of vertex coordinates through quantization, derived from CityJSON's transform object \citep{cityjson_spec}

  \item \textbf{reference\_system} - \textit{ReferenceSystem table} - Coordinate reference system information including:
    \begin{itemize}
      \item \textit{authority} - Authority name, typically "EPSG"
      \item \textit{code} - Numeric identifier of the CRS
      \item \textit{version} - Version of the CRS definition
    \end{itemize}

  \item \textbf{geographical\_extent} - \textit{GeographicalExtent struct} - 3D bounding box containing min/max coordinates for the dataset \citep{cityjson_spec}

  \item \textbf{identifier} - \textit{string} - Unique identifier for the dataset

  \item \textbf{title} - \textit{string} - Human-readable title for the dataset

  \item \textbf{reference\_date} - \textit{string} - Date of reference for the dataset

  \item \textbf{point of contact} - Contact information for the dataset provider \citep{cityjson_spec}:
    \begin{itemize}
      \item \textit{poc\_contact\_name} - Name of the point of contact
      \item \textit{poc\_contact\_type} - Type of contact (\eg, "individual", "organization")
      \item \textit{poc\_role} - Role of the contact (\eg, "author", "custodian")
      \item \textit{poc\_email} - Email address of the contact
      \item \textit{poc\_website} - Website for the contact
      \item \textit{poc\_phone} - Phone number of the contact
      \item \textit{poc\_address\_*} - Address components including thoroughfare number, name, locality, postcode, country
    \end{itemize}
\end{itemize}


\subsection{Appearance Information}
\label{methodology:header:appearance}

Fields storing global appearance definitions:

\begin{itemize}
  \item \textbf{appearance} - \textit{Appearance table} - Container for visual representation properties, following CityJSON's appearance model \citep{cityjson_spec}, containing:
    \begin{itemize}
      \item \textit{materials} - Array of Material tables with the following properties:
        \begin{itemize}
          \item \textit{name} - Required string identifier for the material
          \item \textit{ambient\_intensity} - Double precision value from 0.0 to 1.0
          \item \textit{diffuse\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{emissive\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{specular\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{shininess} - Double precision value from 0.0 to 1.0
          \item \textit{transparency} - Double precision value from 0.0 to 1.0
          \item \textit{is\_smooth} - Boolean flag for smooth shading
        \end{itemize}

      \item \textit{textures} - Array of Texture tables with the following properties:
        \begin{itemize}
          \item \textit{type} - TextureFormat enum (PNG, JPG)
          \item \textit{image} - Required string containing image file name or URL
          \item \textit{wrap\_mode} - WrapMode enum (None, Wrap, Mirror, Clamp, Border)
          \item \textit{texture\_type} - TextureType enum (Unknown, Specific, Typical)
          \item \textit{border\_color} - Array of double values (RGBA) from 0.0 to 1.0
        \end{itemize}

      \item \textit{vertices\_texture} - Array of Vec2 structs containing UV coordinates (u,v), each coordinate value must be between 0.0 and 1.0 for proper texture mapping

      \item \textit{default\_theme\_material} and \textit{default\_theme\_texture} - Strings identifying default themes for rendering when multiple themes are defined
    \end{itemize}
\end{itemize}

The appearance model provides a standardized way to define visual properties of city objects, supporting multiple rendering engines and visualization tools. Materials define surface properties while textures allow mapping of image data onto geometry surfaces. The separation of appearance definitions from geometry enables efficient storage by allowing multiple surfaces to reference the same materials or textures.

\subsection{Geometry Templates}
\label{methodology:header:geometry_templates}

Fields supporting geometry reuse:

\begin{itemize}
  \item \textbf{templates} - \textit{Array of Geometry tables} - Reusable geometry definitions that can be instantiated multiple times, following CityJSON's template concept \citep{cityjson_spec}

  \item \textbf{templates\_vertices} - \textit{Array of DoubleVertex structs} - Double-precision vertices used by templates, stored separately from feature vertices for higher precision in the local coordinate system \citep{cityjson_spec}
\end{itemize}

The templates mechanism enables significant storage efficiency for datasets containing repetitive structures such as standardised building designs, street furniture, or vegetation. The detailed structure of geometry encoding, including boundary representation and semantic surface classification, will be explained further in \autoref{methodology:feature_encoding}.

\subsection{Extension Support}
\label{methodology:header:extensions}

Fields enabling schema extensibility:

\begin{itemize}
  \item \textbf{extensions} - \textit{Array of Extension tables} - Definitions for CityJSON extensions \citep{cityjson_spec}, each containing:
    \begin{itemize}
      \item \textit{name} - Extension identifier (\eg, "+Noise")
      \item \textit{url} - Reference to the extension schema
      \item \textit{version} - Extension version identifier
      \item \textit{extra\_attributes}, \textit{extra\_city\_objects}, \textit{extra\_root\_properties}, \textit{extra\_semantic\_surfaces} - Stringified JSON schemas for extension components
    \end{itemize}
\end{itemize}

Unlike standard CityJSON \citep{cityjson_spec}, which references external schema definition files for extensions, FlatCityBuf embeds the complete extension schemas directly within the file as stringified JSON. This approach creates a self-contained, all-in-one data format that can be interpreted correctly without requiring access to external resources.

The embedding of extension schemas follows FlatCityBuf's design principle of maintaining file independence while preserving full compatibility with the CityJSON extension mechanism. The specific implementation details of how extended city objects and semantic surfaces are encoded in individual features will be explained further in \autoref{methodology:feature_encoding}.

\subsection{Attribute Schema and Indexing Metadata}
\label{methodology:header:schema_indexing}

Fields supporting attribute interpretation and efficient querying:

\begin{itemize}
  \item \textbf{columns} - \textit{Array of Column tables} - Schema definitions for attribute data. This metadata is used to interpret the values of the attributes in the features. Each containing:
    \begin{itemize}
      \item \textit{index} - Numeric identifier of the column
      \item \textit{name} - Name of the attribute (\eg, "cityname", "owner", \etc)
      \item \textit{type} - Data type enumeration (\eg, "Int", "String", \etc)
      \item \textit{nullable}, \textit{unique}, \textit{precision} - Optional metadata for validating and interpreting values
    \end{itemize}

  \item \textbf{features\_count} - \textit{ulong} - Total number of features in the dataset, enables client applications to pre-allocate resources

  \item \textbf{index\_node\_size} - \textit{ushort} - Number of entries per node in the spatial index, defaults to 16, tuned for typical HTTP request sizes

  \item \textbf{attribute\_index} - \textit{Array of AttributeIndex structs} - Metadata for each attribute index, containing:
    \begin{itemize}
      \item \textit{index} - Reference to the column being indexed
      \item \textit{length} - Size of the index in bytes
      \item \textit{branching\_factor} - Branching factor of the index, number of items in each node is equal to $\text{branching factor} - 1$
      \item \textit{num\_unique\_items} - Count of unique values for this attribute
    \end{itemize}
\end{itemize}

\todo{add more details about here}
\subsection{Implementation Considerations}
\label{methodology:header:implementation}

The header is designed to be compact while providing all necessary information to interpret the file. The size-prefixed FlatBuffers encoding enables efficient skipping of the header when only specific features are needed, important for cloud-based access patterns where minimising data transfer is essential. All numeric values in the header use little-endian encoding for consistency with modern architectures.
