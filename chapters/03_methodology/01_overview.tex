%!TEX root = ../../thesis.tex

\chapter{Methodology}
\label{methodology}

This chapter presents the design and implementation of FlatCityBuf, a cloud-optimised binary format for 3D city models based on CityJSON. The proposed approach addresses the limitations of existing formats through efficient binary encoding, spatial indexing, attribute indexing, and support for partial data retrieval.

\section{Overview}
\label{methodology:overview}

\subsection{Methodology Approach}
\label{methodology:overview:approach}

Current 3D city model formats like CityGML, CityJSON, and CityJSONSeq (also \ac{cjseq}) exhibit limitations in cloud environments with large-scale datasets, including retrieval latency, inefficient spatial querying without additional software support, and insufficient support for partial data access.

This research methodology addresses these limitations through three interconnected objectives:

\begin{enumerate}
    \item Development of a binary encoding strategy using FlatBuffers that preserves semantic richness while achieving faster read performance
    \item Implementation of dual indexing mechanisms—spatial (Packed Hilbert R-tree) and attribute-based (Static B+tree)—that accelerate query performance
    \item Integration of cloud-native data access patterns through HTTP Range Requests, enabling partial data retrieval
\end{enumerate}

\subsection{File Structure Overview}
\label{methodology:overview:file_structure}

The FlatCityBuf format implements a structured binary encoding with five sequentially arranged components:

\begin{itemize}
    \item \textbf{Magic bytes}: Eight-byte identifier ('FCB\\0') for format validation
    \item \textbf{Header section}: Contains metadata, schema definitions, and CityJSON properties
    \item \textbf{Spatial index}: Implements a Packed Hilbert R-tree for efficient geospatial queries
    \item \textbf{Attribute index}: Utilises a Static B+tree for accelerated attribute-based filtering
    \item \textbf{Features section}: Stores city objects encoded as FlatBuffers tables
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{figs/methodology/file_structure.png}
  \caption{Physical layout of the FlatCityBuf file format, showing section boundaries and alignment considerations for optimised range requests}
  \label{fig:methodology:file-structure}
\end{figure}

This sequence-based structure enables incremental file access through HTTP Range Requests—critical for cloud-based applications where minimising data transfer is essential. Each section is designed with explicit consideration for alignment boundaries to optimise I/O operations.

\subsection{Note on Binary Encoding}
\label{methodology:overview:note_on_binary_encoding}
\todo{add reference why these two}
FlatCityBuf follows two key conventions for encoding binary data throughout the file format:

\begin{enumerate}
    \item \textbf{Size-prefixed FlatBuffers}: All FlatBuffers records (header and features) include a 4-byte unsigned integer prefix indicating the buffer size. This enables programs to know the size of the record without parsing the entire content. The FlatBuffers API implements this through \texttt{finish\_size\_prefixed} or equivalent language-specific methods.

    \item \textbf{Little-endian encoding}: For data encoded outside FlatBuffers records (particularly in spatial and attribute indices), little-endian byte ordering is consistently applied. This includes numeric values such as 32-bit and 64-bit integers, floating-point numbers, and offset values within indices.
\end{enumerate}

\todo{add reference}
These conventions ensure consistency across the file format and maximise compatibility with modern CPU architectures, most of which use little-endian byte ordering. The size-prefixing mechanism is particularly important for cloud-based access patterns, as it facilitates precise HTTP Range Requests when retrieving specific file segments.
