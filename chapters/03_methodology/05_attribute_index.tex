%!TEX root = ../../thesis.tex

\section{Attribute Indexing}
\label{methodology:attribute_index}

Attribute indexing is a fundamental component of the FlatCityBuf format, enabling efficient filtering and retrieval of city objects based on their non-spatial properties. This section details the requirements, design considerations, and implementation of the attribute indexing system.

\subsection{Query Requirements Analysis}
\label{methodology:attribute_index:query_requirements}

The attribute indexing system was designed to support specific query patterns commonly used in geospatial applications. Based on an analysis of typical use cases, the following query types were identified as essential:

\begin{itemize}
    \item \textbf{Exact Match}: Queries that seek records matching a specific attribute value (e.g., \texttt{building\_type = "residential"})
    \item \textbf{Range Queries}: Queries that select records with attribute values falling within a specified range (e.g., \texttt{height >= 10 AND height <= 20})
    \item \textbf{Compound Conditions}: Multiple conditions combined with logical operators (e.g., \texttt{building\_type = "residential" AND height > 15})
\end{itemize}

While the SQL standard \citep{iso_9075_2_2023} defines a comprehensive set of predicates and operators for database querying, implementing the full spectrum of these capabilities is beyond the scope of this research. FlatCityBuf deliberately focuses on a subset of operators that provide the greatest utility for typical 3D city model queries while maintaining efficient implementation over HTTP.

Notably absent are pattern-matching operations such as the SQL \texttt{LIKE} operator (e.g., \texttt{city LIKE "Delf\%"}), which would require specialized text indexing structures. Similarly, functions like \texttt{CONTAINS}, \texttt{BETWEEN}, aggregate functions (\texttt{COUNT}, \texttt{SUM}, etc.), and advanced text search capabilities were deemed lower priority compared to the core comparison operators. These advanced query types can be implemented at the application layer after retrieving the relevant data.

The system prioritises these core query types while ensuring compatibility with remote access patterns through HTTP Range Requests. This focused approach aligns with FlatCityBuf's primary goal as an efficient storage and retrieval format rather than a comprehensive query processing system.


\subsection{Static B+tree Design}
\label{methodology:attribute_index:static_btree_design}

After evaluating alternatives, a Static B+tree (S+tree) approach was adopted. This decision was based on the following considerations:

\begin{itemize}
    \item \textbf{Block-Oriented Access}: B+trees organise data into fixed-size nodes (typically matching file system block sizes), minimising the number of I/O operations required.
    \item \textbf{HTTP Range Request Efficiency}: By aligning nodes with typical block sizes (4KB), the structure optimises for HTTP Range Requests, reducing the number of network roundtrips.
    \item \textbf{Balanced Performance}: The structure offers $O(\log_B n)$ search complexity where $B$ is the branching factor, significantly reducing the number of node accesses compared to a binary search tree.
    \item \textbf{Range Query Support}: The leaf-level organisation of B+trees facilitates efficient range queries through sequential access.
\end{itemize}

The implementation uses a static variant of the B+tree, built once and used for read-only operations. This design choice aligns with the immutable nature of the FlatCityBuf format and enables additional optimisations not possible with dynamic tree structures.

\subsection{Implicit Layout and Memory Efficiency}
\label{methodology:attribute_index:implicit_layout}

The Static B+tree implementation uses an Eytzinger layout for node placement, offering several benefits:

\begin{itemize}
    \item \textbf{Implicit Structure}: No explicit pointers are stored between nodes, reducing storage overhead.
    \item \textbf{Cache Locality}: Nodes at the same level are stored contiguously, improving cache efficiency.
    \item \textbf{Minimal Metadata}: The tree structure is determined mathematically based on the branching factor and number of entries.
\end{itemize}

This approach produces a compact, cache-friendly structure that requires minimal metadata while maintaining excellent query performance. Internally, the layout is constructed using the following algorithm:

\begin{enumerate}
    \item Calculate level bounds based on the branching factor and total number of entries
    \item Copy leaf nodes from the sorted array of entries
    \item Build internal nodes bottom-up, selecting appropriate separator keys
    \item Store nodes contiguously in level order (root first, then each subsequent level)
\end{enumerate}

\subsection{Type-Specific Serialisation}
\label{methodology:attribute_index:type_specific_serialisation}

The attribute index supports various data types common in 3D city models, including:

\begin{itemize}
    \item \textbf{Numeric Types}: Integers (i8, i16, i32, i64, u8, u16, u32, u64) and floating-point values (f32, f64)
    \item \textbf{Temporal Types}: Dates and timestamps with timezone information
    \item \textbf{String Types}: Fixed-width strings with prefix encoding
    \item \textbf{Boolean Values}: Represented as single bytes
\end{itemize}

Each type implements a specialised serialisation strategy that preserves ordering semantics while optimising storage efficiency. For floating-point values, the implementation uses `OrderedFloat` to handle NaN values correctly. Strings utilise a fixed-width prefix encoding that balances storage requirements with efficient comparison operations.

\subsection{Duplicate Key Handling}
\label{methodology:attribute_index:duplicate_key_handling}

A significant optimisation in the attribute index is the handling of duplicate keys:

\begin{itemize}
    \item \textbf{Primary Index Structure}: Contains only unique keys, with pointers to either direct feature offsets or to a payload section
    \item \textbf{Payload Section}: Stores lists of offsets for duplicate key values
    \item \textbf{Tag Bit}: The most significant bit of the offset value indicates whether it points directly to a feature or to the payload section
\end{itemize}

This approach maintains the efficiency of the tree structure while properly handling attributes with many duplicate values. For example, building type attributes often have many identical values (e.g., hundreds of "residential" buildings), which are all efficiently indexed through a single payload reference.

\subsection{HTTP Optimisation Techniques}
\label{methodology:attribute_index:http_optimisation}

The attribute index implements several techniques specifically designed to optimise performance over HTTP:

\begin{itemize}
    \item \textbf{Payload Prefetching}: Proactively caches parts of the payload section during initial query execution, reducing HTTP requests for duplicate keys.
    \item \textbf{Batch Payload Resolution}: Collects multiple payload references during tree traversal and resolves them with consolidated HTTP requests.
    \item \textbf{Request Batching}: Groups adjacent node requests to minimise network roundtrips.
    \item \textbf{Block Alignment}: Nodes are aligned to 4KB boundaries to match typical file system and HTTP caching patterns.
\end{itemize}

Internal testing demonstrated that these optimisations reduce HTTP requests by up to 90\% for typical queries compared to na√Øve implementations, significantly improving overall query performance for web-based applications.

\subsection{Multi-Index Query Execution}
\label{methodology:attribute_index:multi_index_query}

The attribute indexing system supports complex queries across multiple attributes through a coordinated query execution strategy:

\begin{enumerate}
    \item Each condition in the query is evaluated against the appropriate attribute index
    \item Results from individual conditions are represented as sets of feature offsets
    \item For conjunctive queries (AND logic), set intersection determines the final result
    \item For disjunctive queries (OR logic), set union combines the results
\end{enumerate}

The implementation provides specialised index structures for different access patterns:

\begin{itemize}
    \item \textbf{MemoryIndex}: For in-memory operations with the entire index loaded
    \item \textbf{StreamIndex}: For file-based access using standard Read+Seek operations
    \item \textbf{HttpIndex}: For remote access using HTTP Range Requests
\end{itemize}

Each implementation provides semantically equivalent operations while optimising for its specific access pattern, ensuring consistent results regardless of the access method.

\subsection{Performance Characteristics}
\label{methodology:attribute_index:performance_characteristics}

The Static B+tree implementation demonstrates several key performance characteristics:

\begin{itemize}
    \item \textbf{Query Complexity}: $O(\log_B n)$ node accesses for both exact match and range queries, where $B$ is the branching factor (typically 16)
    \item \textbf{Storage Efficiency}: Approximately 8 bytes per indexed entry plus payload overhead for duplicate keys
    \item \textbf{Construction Time}: $O(n \log n)$ for sorting plus $O(n)$ for tree construction
    \item \textbf{HTTP Efficiency}: Typically 3-5 HTTP requests per query for moderate-sized datasets (millions of entries)
\end{itemize}

Benchmarks conducted with various datasets demonstrated query performance 10-20 times faster than traditional approaches when accessed over HTTP, particularly for datasets with many duplicate attribute values.

The combination of block-oriented design, implicit layout, and HTTP optimisations results in an attribute indexing system that efficiently supports the required query patterns while minimising both storage requirements and network overhead.
