\section{Magic Bytes}
\label{methodology:file_components:magic_bytes}

The magic bytes section comprises the first eight bytes of the file:
\todo{check detail again}
\begin{itemize}
  \item The first three bytes contain the ASCII sequence 'FCB' (0x46 0x43 0x42) serving as an immediate identifier
  \item The remaining five bytes represent the version number of the file format, comprised with Semantic Versioning (SemVer) \citep{semver}. As the current version is 0.1.0, the magic bytes are 'FCB010' (0x46 0x43 0x42 0x30 0x31 0x30). The last two bytes are reserved for future use and must be set to zero.
\end{itemize}

This signature design enables applications to validate file type and version compatibility without parsing the entire header content. The approach was directly inspired by FlatGeoBuf's methodology, which uses 'FGB' (F, G, B characters) in its magic bytes to indicate 'FlatGeoBuf' \citep{horance_2022}.

\section{Header Section}
\label{methodology:file_components:header}

The header section encapsulates metadata essential for interpreting the file contents, implemented as a size-prefixed FlatBuffers-serialised \texttt{Header} table. The header serves a dual purpose: it maintains compatibility with CityJSON by encoding the equivalent of the first line of a \ac{cjseq} stream \citep{ledoux_2024}—which contains the root CityJSON object with metadata, coordinate reference system, and transformations—while adding FlatCityBuf-specific extensions for optimised retrieval and indexing. The full schema definition for the header can be found in \autoref{appendix:flatcitybuf_schema}.

In a \ac{cjseq} file, the first line contains a valid CityJSON object with empty \texttt{CityObjects} and \texttt{vertices} arrays but with essential global properties like \texttt{transform}, \texttt{metadata}, and \texttt{version}. The FlatCityBuf header encodes these same properties alongside additional indexing information required for cloud-optimised access patterns.

\subsection{CityJSON Metadata Fields}
\label{methodology:header:cityjson_fields}

Here are the core header fields with their data types and significance:

\begin{itemize}
  \item \textbf{version} - \textit{string (required)} - CityJSON version identifier (\eg, "2.1"), required field from CityJSON specification \citep{cityjson_spec}

  \item \textbf{transform} - \textit{Transform struct} - Contains scale and translation vectors enabling efficient storage of vertex coordinates through quantization, derived from CityJSON's transform object \citep{cityjson_spec}

  \item \textbf{reference\_system} - \textit{ReferenceSystem table} - Coordinate reference system information including:
    \begin{itemize}
      \item \textit{authority} - Authority name, typically "EPSG"
      \item \textit{code} - Numeric identifier of the CRS
      \item \textit{version} - Version of the CRS definition
    \end{itemize}

  \item \textbf{geographical\_extent} - \textit{GeographicalExtent struct} - 3D bounding box containing min/max coordinates for the dataset \citep{cityjson_spec}

  \item \textbf{identifier} - \textit{string} - Unique identifier for the dataset

  \item \textbf{title} - \textit{string} - Human-readable title for the dataset

  \item \textbf{reference\_date} - \textit{string} - Date of reference for the dataset

  \item \textbf{point of contact} - Contact information for the dataset provider \citep{cityjson_spec}:
    \begin{itemize}
      \item \textit{poc\_contact\_name} - Name of the point of contact
      \item \textit{poc\_contact\_type} - Type of contact (\eg, "individual", "organization")
      \item \textit{poc\_role} - Role of the contact (\eg, "author", "custodian")
      \item \textit{poc\_email} - Email address of the contact
      \item \textit{poc\_website} - Website for the contact
      \item \textit{poc\_phone} - Phone number of the contact
      \item \textit{poc\_address\_*} - Address components including thoroughfare number, name, locality, postcode, country
    \end{itemize}
\end{itemize}


\subsection{Appearance Information}
\label{methodology:header:appearance}

Fields storing global appearance definitions:

\begin{itemize}
  \item \textbf{appearance} - \textit{Appearance table} - Container for visual representation properties, following CityJSON's appearance model \citep{cityjson_spec}, containing:
    \begin{itemize}
      \item \textit{materials} - Array of Material tables with the following properties:
        \begin{itemize}
          \item \textit{name} - Required string identifier for the material
          \item \textit{ambient\_intensity} - Double precision value from 0.0 to 1.0
          \item \textit{diffuse\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{emissive\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{specular\_color} - Array of double values (RGB) from 0.0 to 1.0
          \item \textit{shininess} - Double precision value from 0.0 to 1.0
          \item \textit{transparency} - Double precision value from 0.0 to 1.0
          \item \textit{is\_smooth} - Boolean flag for smooth shading
        \end{itemize}

      \item \textit{textures} - Array of Texture tables with the following properties:
        \begin{itemize}
          \item \textit{type} - TextureFormat enum (PNG, JPG)
          \item \textit{image} - Required string containing image file name or URL
          \item \textit{wrap\_mode} - WrapMode enum (None, Wrap, Mirror, Clamp, Border)
          \item \textit{texture\_type} - TextureType enum (Unknown, Specific, Typical)
          \item \textit{border\_color} - Array of double values (RGBA) from 0.0 to 1.0
        \end{itemize}

      \item \textit{vertices\_texture} - Array of Vec2 structs containing UV coordinates (u,v), each coordinate value must be between 0.0 and 1.0 for proper texture mapping

      \item \textit{default\_theme\_material} and \textit{default\_theme\_texture} - Strings identifying default themes for rendering when multiple themes are defined
    \end{itemize}
\end{itemize}

The appearance model standardizes visual properties of city objects, with materials defining surface properties and textures mapping images onto geometry. This separation from geometry allows efficient storage through shared material and texture references.

\subsection{Geometry Templates}
\label{methodology:header:geometry_templates}

Fields supporting geometry reuse:

\begin{itemize}
  \item \textbf{templates} - \textit{Array of Geometry tables} - Reusable geometry definitions that can be instantiated multiple times, following CityJSON's template concept \citep{cityjson_spec}

  \item \textbf{templates\_vertices} - \textit{Array of DoubleVertex structs} - Double-precision vertices used by templates, stored separately from feature vertices for higher precision in the local coordinate system \citep{cityjson_spec}
\end{itemize}

The templates mechanism enables significant storage efficiency for datasets containing repetitive structures such as standardised building designs, street furniture, or vegetation. The detailed structure of geometry encoding, including boundary representation and semantic surface classification, will be explained further in \autoref{methodology:feature_encoding:geometry_encoding}.

\subsection{Extension Support}
\label{methodology:header:extensions}

Fields enabling to accommodate CityJSON's extension mechanism:

\begin{itemize}
  \item \textbf{extensions} - \textit{Array of Extension tables} - Definitions for CityJSON extensions \citep{cityjson_spec}, each containing:
    \begin{itemize}
      \item \textit{name} - Extension identifier (\eg, "+Noise")
      \item \textit{url} - Reference to the extension schema
      \item \textit{version} - Extension version identifier
      \item \textit{extra\_attributes}, \textit{extra\_city\_objects}, \textit{extra\_root\_properties}, \textit{extra\_semantic\_surfaces} - Stringified JSON schemas for extension components
    \end{itemize}
\end{itemize}

Unlike standard CityJSON \citep{cityjson_spec}, which references external schema definition files for extensions, FlatCityBuf embeds the complete extension schemas directly within the file as stringified JSON. This approach creates a self-contained, all-in-one data format that can be interpreted correctly without requiring access to external resources.

The embedding of extension schemas follows FlatCityBuf's design principle of maintaining file independence while preserving full compatibility with the CityJSON extension mechanism. The specific implementation details of how extended city objects and semantic surfaces are encoded in individual features will be explained further in \autoref{methodology:feature_encoding}.

\subsection{Attribute Schema and Indexing Metadata}
\label{methodology:header:schema_indexing}

Fields supporting attribute interpretation and efficient querying:

\begin{itemize}
  \item \textbf{columns} - \textit{Array of Column tables} - Schema definitions for attribute data. This metadata is used to interpret the values of the attributes in the features. Each containing:
    \begin{itemize}
      \item \textit{index} - Numeric identifier of the column
      \item \textit{name} - Name of the attribute (\eg, "cityname", "owner", \etc)
      \item \textit{type} - Data type enumeration (\eg, "Int", "String", \etc)
      \item \textit{nullable}, \textit{unique}, \textit{precision} - Optional metadata for validating and interpreting values
    \end{itemize}

  \item \textbf{semantic\_columns} - \textit{Array of Column tables} - Schema definitions for semantic surface attributes. Similar to the \texttt{columns} field, but specifically for interpreting attribute data attached to semantic surfaces in the geometry. This separation allows for different attribute schemas between city objects and their semantic surfaces.

  \item \textbf{features\_count} - \textit{ulong} - Total number of features in the dataset, enables client applications to pre-allocate resources

  \item \textbf{index\_node\_size} - \textit{ushort} - Number of entries per node in the spatial index, defaults to 16, tuned for typical HTTP request sizes

  \item \textbf{attribute\_index} - \textit{Array of AttributeIndex structs} - Metadata for each attribute index, containing:
    \begin{itemize}
      \item \textit{index} - Reference to the column being indexed
      \item \textit{length} - Size of the index in bytes
      \item \textit{branching\_factor} - Branching factor of the index, number of items in each node is equal to $\text{branching factor} - 1$
      \item \textit{num\_unique\_items} - Count of unique values for this attribute
    \end{itemize}
\end{itemize}

The attribute schema system in FlatCityBuf is designed to efficiently interpret binary-encoded attribute values. By separating city object attributes from semantic surface attributes through the distinct \texttt{columns} and \texttt{semantic\_columns} arrays, the format enables more flexible modelling of properties at different levels of the city model hierarchy. This separation is particularly useful for modelling scenarios where semantic surfaces require specialized attributes (such as material properties, thermal characteristics, or solar potential) distinct from the attributes of their parent city objects.

\subsection{Implementation Considerations}
\label{methodology:header:implementation_considerations}

The header is designed to be compact while providing all necessary information to interpret the file. The size-prefixed FlatBuffers encoding enables efficient skipping of the header when only specific features are needed, important for cloud-based access patterns where minimising data transfer is essential. All numeric values in the header use little-endian encoding for consistency with modern architectures.
