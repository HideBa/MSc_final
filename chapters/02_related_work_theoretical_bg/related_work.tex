%!TEX root = ../../thesis.tex

\chapter{Related Work}
\label{rw:related_work}
This chapter reviews the pertinent literature relevant to the optimisation of CityJSON for cloud-native environments. It highlights advancements and identifies existing gaps that this research aims to address.

\section{Cloud-Optimised Geospatial Formats}
\label{rw:cloud_optimised_formats}

Cloud-optimised geospatial formats are data formats that are optimised for cloud environments by enabling efficient on-demand access to geospatial data in contrast to traditional GIS formats \citep{cloud-optimised-formats}. \citet{cloud-optimised-formats} defines four advantages of cloud-optimised geospatial formats:

\begin{itemize}
  \item \textbf{Reduced Latency}: Facilitates partial data retrieval and processing without necessitating complete file downloads.
  \item \textbf{Scalability}: Supports parallel operations through metadata-driven access mechanisms within cloud storage systems.
  \item \textbf{Flexibility}: Offers advanced query capabilities for selective data access.
  \item \textbf{Cost-Effectiveness}: Optimises storage and transfer expenditures through efficient access patterns.
\end{itemize}

These include Cloud Optimised GeoTIFF, Cloud Optimised Point Cloud, GeoParquet, PMTiles, and FlatGeobuf. Although not mentioned by \citet{cloud-optimised-formats}, 3D Tiles \citep{3d_tiles} and Mapbox Vector Tiles \citep{mapbox-vector-tiles} can also be considered as cloud-optimised geospatial formats since they were developed by Web GIS companies Cesium and Mapbox respectively.

\section{CityGML, CityJSON and Its Enhancements}
\label{rw:cityjson_enhancements}

\subsection{CityGML}
\label{rw:citygml}
CityGML is an \ac{ogc} standard \citep{CityGML} that defines a comprehensive data model for representing 3D city models. The standard encompasses both geometric properties and rich semantic information through a modular structure. From version 3.0.0, CityGML separates its conceptual model from its encoding standard. \autoref{fig:citygml_modules} shows an overview of its modules. The conceptual model defines the semantics and data model through a Core module and eleven thematic extension modules (Building, Bridge, Tunnel, Construction, CityFurniture, CityObjectGroup, LandUse, Relief, Transportation, Vegetation, and WaterBody). Additionally, five extension modules (Appearance, PointCloud, Generics, Versioning, and Dynamizer) provide specialised modelling capabilities applicable across all thematic modules. The encoding standard uses GML application schema for the Geography Markup Language (GML) \citep{gml} to encode the data. This modular design allows implementations to support specific subsets of modules based on their application requirements, ensuring flexibility while maintaining standard compliance.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{figs/related_work_theoretical_bg/citygml3modules.png}
  \caption[CityGML 3.0 Module Overview]{Overview of CityGML 3.0 modules showing the Core module, thematic extension modules, and additional extension modules. Source: \citep{CityGML}}
  \label{fig:citygml_modules}
\end{figure}

\subsection{CityJSON}
\label{rw:cityjson}

CityJSON is a JSON-based \citep{json} encoding format that implements a subset of the CityGML conceptual model \citep{CityGML}. It is an official \ac{ogc} community standard \citep{ogc} currently at version 2.0.1, supporting CityGML 3.0.0. While both CityGML and CityJSON implement the CityGML conceptual model, CityJSON exhibits several notable differences.

The following properties of CityJSON are derived from \citet{ledoux_2019}:

\subsubsection{Flattened City Objects Architecture}
\label{rw:cityjson:flattened_architecture}

CityJSON implements a flattened architecture where each city object receives a unique identifier, contrasting with CityGML's hierarchical structure. While CityGML maintains a hierarchical organisation, CityJSON stores all objects at the same level (e.g., first and second-level city objects are stored in the same dictionary). To preserve hierarchical relationships, CityJSON uses a \texttt{parents} field to reference each object's parent.

\subsubsection{Geometry}
\label{rw:cityjson:geometry}

CityJSON supports the same 3D geometric primitives as CityGML. However, instead of storing vertex coordinates directly within geometric primitives, CityJSON maintains a separate \texttt{vertices} array containing all coordinates. Geometric primitives then reference vertex positions within this array.

\subsubsection{Semantic Surfaces}
\label{rw:cityjson:semantic_surfaces}

CityJSON stores semantic surfaces as separate objects, recognising that city objects often share common semantics. This is implemented through \texttt{semanticSurfaces} fields and a \texttt{values} array that maps surfaces to their corresponding semantic surface objects.

This is an example of how the semantic surfaces look like (derived from \citet{ledoux_2019}):

\begin{lstlisting}
  {
    "type": "Solid",
    "lod": 2,
    "boundaries": [
      [ [[0,3,2,1,22]], [[4,5,6,7]], [[0,1,5,4]],
        [[1,2,6,5]] ]
      ],
      "semantics": {
        "surfaces" : [
          { "type": "RoofSurface" },
          {
            "type": "WallSurface",
            "paint": "blue"
          },
          { "type": "GroundSurface" }
        ],
        "values": [ [0, 1, 1, 2] ]
      }
    }
  }
\end{lstlisting}

\subsubsection{Geometry Templates}
\label{rw:cityjson:geometry_templates}

CityJSON implements CityGML's Implicit Geometry concept through "geometry templates". The format includes \texttt{geometry-templates} fields with a \texttt{templates} array that stores reusable geometries. City objects utilising these templates specify \texttt{"GeometryInstance"} in their geometry's \texttt{type} field to indicate template reuse.

This code shows an example of a geometry template derived from \citet{ledoux_2019}:

\begin{lstlisting}
  {
    "geometry-templates": {
      "templates": [{
        "type": "MultiSurface",
        "lod": 2,
        "boundaries": [
          [[0, 3, 2, 1]],
          [[4, 5, 6, 7]],
          [[0, 1, 5, 4]]
        ]
      }],
      "vertices-templates": [...]
    }
  }
\end{lstlisting}

And this is how a city object references this template:

\begin{lstlisting}
  {
    "type": "SolitaryVegetationObject",
    "geometry": [
      {
        "type": "GeometryInstance",
        "template": 0,
        "boundaries": [372],
        "transformationMatrix": [
          2.0, 0.0, 0.0, 0.0,
          0.0, 2.0, 0.0, 0.0,
          0.0, 0.0, 2.0, 0.0,
          0.0, 0.0, 0.0, 1.0
        ]
      }
    ]
  }
\end{lstlisting}

\subsubsection{Coordinate Quantisation}
\label{rw:cityjson:coordinate_quantisation}

CityJSON employs coordinate quantisation to reduce geometry size. The \texttt{transform} field contains \texttt{scale} and \texttt{translate} values for coordinate quantisation. The original coordinates are recovered using the following formula (e.g., for the x component of vertex $v$):
\begin{equation}
  \label{eq:cityjson:coordinate_quantisation}
  x = v_x \cdot \text{transform.scale}_x + \text{transform.translate}_x
\end{equation}

This is an example of how the transform object looks like (derived from \citet{ledoux_2019}):
\begin{lstlisting}
{
  "transform": {
    "scale": [0.01, 0.01, 0.01],
    "translate": [4424648.79, 5482614.69, 310.19]
  }
}
\end{lstlisting}

\subsubsection{Extension Mechanism}
\label{rw:cityjson:extension_mechanism}

CityJSON implements an extension mechanism using JSON Schema, similar to CityGML's \ac{ade}.
\citet{fillip_2018} provides an overview of the developments of \ac{ade} in CityGML. While CityJSON's extension mechanism maintains compatibility with the core CityGML conceptual model, it has some limitations compared to CityGML's \ac{ade}, particularly in terms of inheritance and namespace support.
The JSON Schema defines the data structure of extensions and can be used to validate extended objects.

CityJSON supports four distinct ways to extend the data model:

\begin{itemize}
  \item Adding new properties at the root level of a CityJSON object (property names must start with \texttt{"+"}, e.g., \texttt{"+census"})
  \item Defining additional attributes for existing city objects (attribute names must start with \texttt{"+"}, e.g., \texttt{"+colour"})
  \item Creating new semantic objects (object names must start with \texttt{"+"}, e.g., \texttt{"+ThermalSurface"})
  \item Creating or extending new city object types (city object names must start with \texttt{"+"}, e.g., \texttt{"+NoiseBuilding"})
\end{itemize}

Each extension must be documented and validated using a JSON Schema file. This schema file must contain specific properties that define the structure and constraints of the extension. For example, an extension schema might look like this (derived from \citet{ledoux_2019}):

\begin{lstlisting}
   {
     "type": "CityJSON_Extension",
     "name": "Noise",
     "uri": "https://someurl.org/noise.json",
     "version": "0.1",
     "description": "Extension to model the noise"
     "extraRootProperties": {},
     "extraAttributes": {},
     "extraCityObjects": {}
  }
\end{lstlisting}

These characteristics, particularly JSON's absence of repetitive closing element tags and the implementation of coordinate quantisation, result in significantly smaller file sizes compared to CityGML, achieving compression factors of up to 7Ã— \citep{ledoux_2019}.

The proposed data format I developed in this research, FlatCityBuf, inherits key concepts from CityJSON including semantic surfaces, geometry templates, coordinate quantisation, and the extension mechanism. The strategy for encoding city objects in FlatCityBuf will be explained in \autoref{methodology}.

\subsection{CityJSON Text Sequences (CityJSONSeq)}
\label{rw:cityjson_enhancements:cityjsonseq}

\citet{ledoux_2024} optimises CityJSON for streaming applications by decomposing objects into independent sequences.
The fundamental unit of CityJSONSeq is the \texttt{CityJSONFeature}, which represents a single feature encompassing a complete city object and its hierarchical children. For instance, a \texttt{CityJSONFeature} representing a \texttt{"Building"} includes its associated \texttt{"BuildingPart"} and \texttt{"BuildingInstallation"} objects. Unlike standard CityJSON objects that share vertices and appearances across multiple features, each \texttt{CityJSONFeature} maintains local vertex lists and appearance data, ensuring complete self-containment of geometric and visual information. Throughout this research, \texttt{CityJSONFeature} objects are referred to simply as \texttt{"features"}. \autoref{fig:cityjsonseq_idea} (sourced from \citet{ledoux_2024}) demonstrates how CityJSONSeq's vertices are stored as local vertices arrays per each feature, contrasting with the shared vertex approach of standard CityJSON.

CityJSONSeq adheres to the Newline Delimited JSON specification \citep{jsonnd}, implementing a structured file format with specific requirements. The first line of a CityJSONSeq file must contain a CityJSON object that stores commonly used data shared across all features, including coordinate transformation parameters (\texttt{transform}), format version information (\texttt{version}), metadata (\texttt{metadata}), reusable geometry templates (\texttt{geometry-templates}), and extension definitions (\texttt{extensions}). This initialisation object establishes the global context for subsequent features.
The example below shows how a \texttt{CityJSONFeature} is represented (derived from \citet{ledoux_2024}):

\begin{lstlisting}
  {
    "type": "CityJSONFeature",
    "id": "id-1",
    "CityObjects": {
      "id-1": {
        "type": "Building",
        "attributes": {
          "roofType": "gabled roof",
          "children": ["my balcony"]
          },
        "geometry": [ ... ]
        },
      "my balcony": {
        "type": "BuildingInstallation",
        "parents": ["id-1"],
        "geometry": [ ... ]
        }
      },
    "vertices": [ ... ],
    "appearance": { ... }
  }
\end{lstlisting}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{figs/related_work_theoretical_bg/cj_idea.pdf}
  \caption[CityJSONSeq Local Vertices]{Comparison of CityJSON and CityJSONSeq showing how vertices are stored. Source: \citep{ledoux_2024}}
  \label{fig:cityjsonseq_idea}
\end{figure}
While CityJSONSeq generally provides improved compression and memory efficiency compared to standard CityJSON, it may produce larger file sizes in scenarios where features share minimal vertex counts or extensively share vertices and textures, due to the necessity of localising previously shared resources.

Despite CityJSONSeq's improvements for streaming applications, its text-based JSON format exhibits several limitations that impede optimal cloud-native performance. The format lacks explicit data typing, storing all values as text strings irrespective of their semantic type (integers, floating-point numbers, booleans), resulting in increased storage overhead and requiring additional parsing operations. Moreover, the JSON structure demands complete data parsing and copying during processing operations, thereby constraining memory efficiency. The absence of built-in indexing mechanisms further restricts efficient spatial and attribute-based querying capabilities. These limitations create opportunities for enhanced cloud-native optimisation through binary encoding schemes that preserve native data types and enable zero-copy access patterns, complemented by integrated indexing mechanisms for efficient data retrieval operations.

\subsection{3DBAG API}
\label{rw:cityjson_enhancements:3dbag_api}

3DBAG is both a dataset and a project dedicated to generating 3D building models for the entire Netherlands \citep{3dbag}. This open data initiative leverages the Register of Buildings and Addresses (BAG) as building footprints and the Actueel Hoogtebestand Nederland (AHN) \citep{ahn}, which serves as the national height model (point cloud) of the Netherlands. The 3DBAG data is automatically generated through the integration of BAG and AHN datasets and is publicly available in multiple formats including CityJSON \citep{ledoux_2019}, Wavefront OBJ \citep{wavefront_obj}, GeoPackage \citep{geopackage}, and FlatGeobuf \citep{flatgeobuf}.

The 3DBAG \ac{api} \citep{3dbag_api} represents one of the project's key web services, providing programmatic access to the dataset by returning CityJSONFeature objects as responses.

\subsection{Enhancements to CityJSON Performance}
\label{rw:cityjson_enhancements:performance}

\subsubsection{Binary Encoding of CityJSON}
\label{rw:cityjson_enhancements:performance:binary_encoding}

\citet{jordi_van_liempt_2020} conducted a systematic evaluation of binary encoding techniques for CityJSON.
This was done to address challenges associated with transmitting large-scale 3D city models over the web.
The study assessed various compression and encoding methodologies, including CBOR, zlib, Draco and their combinations.
It evaluated visualisation time, querying time, spatial analysis time, editing time, file size compression and lossiness.
The analysis determined that the combination of CBOR and zlib offers optimal general-purpose efficiency due to its implementation simplicity.
Conversely, Draco exhibited superior performance for pre-compressed data scenarios.
However, the study identified limitations in Draco's applicability.
Specifically, it noted the increased complexity and computational overhead when handling smaller datasets.
While these findings provide valuable insights for binary encoding implementations, they do not address optimisations tailored to cloud-native environments, particularly partial data retrieval over the web without requiring complete file downloads.

\subsubsection{Experimental Implementation Using FlatBuffers}
\label{rw:cityjson_enhancements:performance:flatbuffers}

\citet{ravi_peters_2024_citybuf} explored the application of FlatBuffers \citep{flatbuffers} for encoding CityJSONFeature.
This was done to enhance performance in cloud-native environments.
The preliminary implementation revealed potential advantages in several key areas:

\begin{itemize}
  \item Faster feature access time.
  \item Lower memory consumption.
  \item Decreased storage requirements.
\end{itemize}

Building upon Peters' initial work, which focused solely on basic CityJSONFeature encoding, this research develops a comprehensive solution that incorporates essential capabilities including spatial indexing, attribute indexing, extensions, textures, and geometry templates. The implementation specifically targets cloud-native environments, prioritising both scalability and efficient data processing to address the limitations of the preliminary approach.

\section{Non-Geospatial Formats in Cloud Environments}
\label{rw:non_geospatial_formats}

Modern cloud-optimised geospatial formats leverage established non-geospatial data structures.
These enhance efficiency in data transfer, storage and processing operations.
Notable implementations include GeoParquet \citep{geoparquet}, which employs Parquet \citep{parquet} for optimised geospatial data management.
\citet{flatgeobuf} is constructed on FlatBuffers \citep{flatbuffers}. Mapbox Vector Tiles \citep{mapbox-vector-tiles} utilise Protocol Buffers (Protobuf) \citep{protobuf}.
These underlying formats are meticulously designed to improve performance metrics.
These include serialisation/deserialisation speed, memory utilisation and data compression.

\subsection{FlatBuffers}
\label{rw:non_geospatial_formats:flatbuffers}

FlatBuffers is a cross-platform serialisation library developed by \citet{google_flatbuffers}.
It is optimised for efficient data access and transfer.
The detailed characteristics and technical implementation of FlatBuffers is explained in \autoref{tb:flatbuffers}.
Benchmark analyses \citep{flatbuffers_benchmark} indicate that FlatBuffers outperforms alternative serialisation formats.
These include Protobuf \citep{protobuf} and JSON, in terms of deserialisation efficiency and memory utilisation.

\subsection{Protocol Buffers (Protobuf)}
\label{rw:non_geospatial_formats:protobuf}

Protobuf, developed by \citet{protobuf}, represents a binary serialisation framework.
It employs schema-based encoding mechanisms for data serialisation.
This framework implements similar fundamental operations to FlatBuffers.
These include schema definition and binary encoding processes.
Notable differences between Protobuf and FlatBuffers include several operational characteristics \citep{protobuf}:
\begin{itemize}
  \item \textbf{Memory Limitations}: Requires complete dataset loading into memory, thereby limiting its applicability for large-scale data processing tasks.
  \item \textbf{Data Parsing Requirements}: Unlike FlatBuffers' zero-copy access, Protobuf requires data parsing during deserialisation, introducing additional computational overhead.
  \item \textbf{Mutability Constraints}: Protobuf allows data modification after deserialisation, whereas FlatBuffers maintains immutable data structures, affecting performance characteristics.
  \item \textbf{Language Support and Community}: Protobuf benefits from broader language support and more extensive community adoption compared to FlatBuffers.
\end{itemize}

\subsection{Apache Parquet}
\label{rw:non_geospatial_formats:parquet}

Apache Parquet \citep{parquet} is a columnar storage format designed to support high-performance compression and encoding schemes for managing extensive datasets.
The Parquet ecosystem includes the specification for the Parquet format \citep{parquet-format}, and various libraries for encoding and decoding Parquet files.

Parquet employs the record shredding and assembly algorithm \citep{dremel_2010} to effectively flatten nested data structures.
Additionally, it implements efficient compression and encoding schemes tailored to column-level data, enhancing both storage efficiency and query performance.

The format utilises a hierarchical data organisation structure consisting of multiple levels:
\begin{itemize}
  \item \textbf{File}: The top-level container that includes metadata and may contain the actual data.
  \item \textbf{Row Group}: A logical horizontal partitioning of data into rows, with each row group containing one column chunk per column in the dataset.
  \item \textbf{Column Chunk}: A contiguous chunk of data for a particular column within a specific row group.
  \item \textbf{Page}: The smallest indivisible unit within column chunks, serving as the fundamental unit for compression and encoding operations.
\end{itemize}

\autoref{fig:parquet_structure} shows the structure of the Parquet format.
This hierarchical organisation enables efficient data access patterns and optimised compression strategies at different granularity levels.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{figs/related_work_theoretical_bg/parquet_structure.png}
  \caption[Parquet Structure]{Parquet structure. Source: \citet{parquet}}
  \label{fig:parquet_structure}
\end{figure}

\subsection{Comparison of Non-Geospatial Formats}
\label{rw:non_geospatial_formats:comparison}

Existing research has evaluated the performance characteristics of non-geospatial formats within cloud environments.
\citet{daniel_persson_2020} conducted a comparative analysis of FlatBuffers and Protobuf.
This focused on metrics such as serialisation/deserialisation efficiency, memory utilisation, and message size optimisation.
Their investigation utilised randomised message sizes to assess format performance in vehicle-to-server communication scenarios.
The analysis yielded the following observations:

\begin{itemize}
  \item \textbf{Processing Efficiency}: Protobuf demonstrated superior serialisation performance but exhibited reduced deserialisation efficiency relative to FlatBuffers.
  \item \textbf{Memory Optimisation}: FlatBuffers consistently displayed lower memory consumption during both serialisation and deserialisation operations.
  \item \textbf{Data Compression}: Protobuf achieved greater message size reduction compared to FlatBuffers.
\end{itemize}

These findings advocate for the selection of FlatBuffers in applications where deserialisation performance and memory efficiency are paramount in data processing operations.

\section{Cloud-Optimised Geospatial Implementations}
\label{rw:cloud_optimised_implementations}
Contemporary cloud-optimised geospatial implementations encompass formats such as Mapbox Vector Tiles \citep{mapbox-vector-tiles}, FlatGeobuf \citep{flatgeobuf}, PMTiles \citep{pmtiles}, and GeoParquet \citep{geoparquet}.

\subsection{Mapbox Vector Tiles (MVT)}
\label{rw:cloud_optimised_implementations:mvt}
\citet{mapbox-vector-tiles} implements a vector tile specification optimised for web-based data delivery. The format utilises Protobuf \citep{protobuf} for the serialisation of two-dimensional geospatial data and adopts a tile pyramid structure to enhance data retrieval operations.

\subsection{PMTiles}
\label{rw:cloud_optimised_implementations:pmtiles}
PMTiles offers a standardised format for managing tile data addressed through Z/X/Y coordinates, supporting both vector and raster tile implementations. The format leverages \ac{http} Range Requests \citep{http_range_requests} to facilitate selective tile retrieval, thereby optimising network resource utilisation.

\subsection{FlatGeobuf}
\label{rw:cloud_optimised_implementations:flatgeobuf}
FlatGeobuf adheres to the Simple Features \citet{simple_features} specification by utilising FlatBuffers \citep{flatbuffers} for serialisation.
The architecture of FlatGeobuf enables efficient serialisation, deserialisation, and data processing operations through its packed Hilbert R-tree spatial index.
This indexing mechanism, combined with stream search capabilities, allows clients to selectively retrieve and process specific geographic regions without necessitating the loading of the entire dataset.
Users and applications can effectively choose subsets of data based on spatial queries, optimising both storage and retrieval operations.
\citet{horance_2022_detail} provides a comprehensive guide for implementers of FlatGeobuf.

\subsection{GeoParquet}
\label{rw:cloud_optimised_implementations:geoparquet}
GeoParquet integrates Parquet's columnar storage architecture to facilitate optimised geospatial data operations \citep{geoparquet}. The format promotes interoperability across cloud data warehouse platforms, including BigQuery \citep{bigquery}, Snowflake \citep{snowflake}, and Redshift \citep{redshift}. Key technical characteristics of GeoParquet include:

\begin{itemize}
  \item \textbf{Compression Efficiency}: Achieves superior compression ratios relative to alternative storage formats through columnar data organisation.
  \item \textbf{Optimised Read Operations}: The columnar architecture enables selective column access and efficient data filtering via predicate pushdown mechanisms, thereby enhancing performance in read-intensive workflows.
\end{itemize}

\subsection{3D Tiles}
\label{rw:cloud_optimised_implementations:3d_tiles}
3D Tiles, an \ac{ogc} standard \citep{3d_tiles}, provides specifications for streaming and rendering extensive three-dimensional urban models. The format implements GLTF \citep{gltf}, a WebGL-optimised specification designed for efficient streaming in web environments.

The data structure employs spatial partitioning through bounding volumes, enabling selective rendering based on camera viewpoint requirements. While this architecture demonstrates optimal performance for visual rendering tasks, it presents limitations in two key areas: (1) arbitrary spatial extent retrieval and (2) attribute-based feature querying capabilities.

\subsection{Comparative Analysis of Cloud-Optimised Geospatial Formats}
\label{rw:cloud_optimised_implementations:comparison}
While acknowledging the inherent limitations of direct format comparisons due to their distinct design objectives and application domains, \autoref{tab:format-comparison} presents a systematic analysis of key operational characteristics across various cloud-optimised geospatial formats. The evaluation criteria and their corresponding scales are detailed in \autoref{tab:criteria-legend}. This analysis facilitates the understanding of format-specific capabilities within their respective operational contexts.

This comparison provides a general overview but is inherently subjective. Direct comparisons may not be entirely fair as each format employs different optimisation strategies and targets different use cases. For example, comparing serialisation performance across formats with varying spatial indexing approaches may not yield meaningful insights, as the indexing overhead varies significantly between implementations.

\begin{table}[htbp]
  \centering
  \caption{Comparative Analysis of Cloud-Optimised Geospatial Formats}
  \label{tab:format-comparison}
  \footnotesize
  \begin{tabular}{p{3cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}|p{1.8cm}}
    \hline
    \textbf{Characteristics} & \textbf{FlatGeobuf} & \textbf{MVT} & \textbf{GeoParquet} & \textbf{GeoJSON} & \textbf{3D Tiles} \\
    \hline
    \textbf{Serialisation Performance} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{orange}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{gray}{\rule{1.2em}{1.2em}}} \\
    \hline
    \textbf{Deserialisation Performance} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}}$^a$ \\
    \hline
    \textbf{Storage Efficiency} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{gray}{\rule{1.2em}{1.2em}}} \\
    \hline
    \textbf{Memory Utilisation} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{gray}{\rule{1.2em}{1.2em}}} \\
    \hline
    \textbf{Implementation Complexity} & \makebox[1.8cm]{\textcolor{orange}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{orange}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{orange}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{orange}{\rule{1.2em}{1.2em}}} \\
    \hline
    \textbf{Spatial Indexing} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}}$^b$ & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}}$^c$ & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}}$^d$ \\
    \hline
    \textbf{Random Access Support} & \makebox[1.8cm]{\textcolor{green}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{yellow}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} & \makebox[1.8cm]{\textcolor{red}{\rule{1.2em}{1.2em}}} \\
    \hline
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Optimised for GPU rendering
  \item[b] Tile-based partitioning
  \item[c] Random access to the internal chunks
  \item[d] Volumetric hierarchical partitioning
  \end{tablenotes}
\end{table}

\begin{table}[htbp]
  \centering
  \caption{Evaluation Criteria Color Legend}
  \label{tab:criteria-legend}
  \footnotesize
  \begin{tabular}{p{2cm}|p{3cm}|p{9cm}}
    \hline
    \textbf{Color} & \textbf{Performance Level} & \textbf{Description} \\
    \hline
    \textcolor{red}{\rule{1.5em}{1.5em}} Red & Poor & Very slow performance, high resource usage, or not supported \\
    \hline
    \textcolor{orange}{\rule{1.5em}{1.5em}} Orange & Below Average & Slow performance or high complexity \\
    \hline
    \textcolor{yellow}{\rule{1.5em}{1.5em}} Yellow & Average & Moderate performance, compression, or basic support \\
    \hline
    \textcolor{green}{\rule{1.5em}{1.5em}} Green & Excellent & Very fast performance, high efficiency, or full support \\
    \hline
    \textcolor{gray}{\rule{1.5em}{1.5em}} Gray & Not Applicable & Feature not available or not applicable to this format \\
    \hline
  \end{tabular}
\end{table}

\section{Research Gaps}
\label{rw:research_gaps}

While existing studies have made advances in optimising CityJSON through various encoding techniques, there remains a deficiency in approaches specifically tailored for 3D city models in cloud environments.
Several geospatial data formats have successfully implemented cloud-native optimisations (as discussed in \autoref{rw:cloud_optimised_implementations}).

Specifically, while advanced serialisation frameworks like FlatBuffers (detailed in \autoref{tb:flatbuffers}) have proven effective in cloud-optimised geospatial formats, their application to 3D city models has not been thoroughly investigated.
For example, FlatGeobuf for Simple Features \citep{flatgeobuf} has shown success.
This research endeavours to address this gap by systematically evaluating and implementing encoding methodologies. These methodologies aim to enhance decoding efficiency and query flexibility within cloud infrastructures, with the potential to achieve file size reduction through optimised binary encoding. The proposed approach is detailed in \autoref{methodology}.