%!TEX root = ../../thesis.tex

\section{FlatBuffers Framework}
\label{rw_tb:fb}

FlatBuffers, developed by \citet{flatbuffers}, is a cross-platform serialisation framework designed specifically for performance-critical applications with a focus on memory efficiency and processing speed. Unlike traditional serialisation approaches, FlatBuffers implements a zero-copy deserialisation mechanism that enables direct access to serialised data without an intermediate parsing step \citep{flatbuffers_benchmark}, as discussed in \autoref{tb:zero_copy}. This characteristic is particularly advantageous for large geospatial datasets where parsing overhead can significantly impact performance.

\subsection{Schema-Based Serialisation}
\label{rw_tb:fb:schema_based_serialisation}

FlatBuffers employs a strongly typed, schema-based approach to data serialisation. The workflow involves:

\begin{enumerate}
    \item Definition of data structures in schema files with the \texttt{.fbs} extension
    \item Compilation of schema files using the FlatBuffers compiler (\texttt{flatc})
    \item Generation of language-specific code for data access
    \item Implementation of application logic using the generated code
\end{enumerate}

This schema-first approach enforces data consistency and type safety, which is essential to be processed in various programming languages and environments. The generated code provides memory-efficient access patterns to the underlying binary data without requiring full deserialisation. FlatCityBuf utilises this capability to achieve a balance between parsing speed and storage efficiency.

The FlatBuffers compiler supports code generation for multiple programming languages, including C++, Java, C\#, Go, Python, JavaScript, TypeScript, Rust, and others, facilitating cross-platform interoperability \citep{flatbuffers_support}. This extensive language support enables developers to work with FlatBuffers data in their preferred environment. For FlatCityBuf, Rust was selected as the primary implementation language due to its performance characteristics and memory safety guarantees.

\subsection{Data Type System}
\label{rw_tb:fb:data_type_system}

FlatBuffers provides a comprehensive type system that balances efficiency and expressiveness \citep{flatbuffers_data_types}:

\begin{itemize}
  \item \textbf{Tables}: Variable-sized object containers that support:
    \begin{itemize}
      \item Named fields with type annotations
      \item Optional fields with default values
      \item Schema evolution through backward compatibility
      \item Non-sequential field storage for memory optimisation
    \end{itemize}

  \item \textbf{Structs}: Fixed-size, inline aggregates that:
    \begin{itemize}
      \item Require all fields to be present (no optionality)
      \item Are stored directly within their containing object
      \item Provide faster access at the cost of schema flexibility
      \item Optimise memory layout for primitive types
    \end{itemize}

  \item \textbf{Scalar Types}:
    \begin{itemize}
      \item 8-bit integers: \texttt{byte} (int8), \texttt{ubyte} (uint8), \texttt{bool}
      \item 16-bit integers: \texttt{short} (int16), \texttt{ushort} (uint16)
      \item 32-bit values: \texttt{int} (int32), \texttt{uint} (uint32), \texttt{float}
      \item 64-bit values: \texttt{long} (int64), \texttt{ulong} (uint64), \texttt{double}
    \end{itemize}

  \item \textbf{Complex Types}:
    \begin{itemize}
      \item \texttt{[T]}: Vectors (single-dimension arrays) of any supported type
      \item \texttt{string}: UTF-8 or 7-bit ASCII encoded text with length prefix
      \item References to other tables, structs, or unions
    \end{itemize}

  \item \textbf{Enums}: Type-safe constants mapped to underlying integer types
  \item \textbf{Unions}: Tagged unions supporting variant types
\end{itemize}

\subsection{Schema Organisation Features}
\label{rw_tb:fb:schema_organisation}

In addition to the data type system, FlatBuffers provides several key features for organising complex schemas:

\begin{itemize}
  \item \textbf{Namespaces} (\texttt{namespace FlatCityBuf;}) create logical boundaries and prevent naming collisions

  \item \textbf{Include Mechanism} (\texttt{include "header.fbs";}) enables modular schema design across multiple files

  \item \textbf{Root Type} (\texttt{root\_type Header;}) identifies the primary table that serves as the entry point for buffer access
\end{itemize}

These features were essential for FlatCityBuf's implementation, enabling modular schema development with separate root types for header and feature components while maintaining consistent type definitions across files.

\todo{move this section to theoretical background?}
\subsection{Binary Structure and Memory Layout}
\label{rw_tb:fb:binary_structure}

FlatBuffers organises serialised data in a flat binary buffer with the following characteristics:

\begin{itemize}
    \item \textbf{Prefix-based vtables} that enable field access without full parsing
    \item \textbf{Offset-based references} that allow direct navigation within the buffer
    \item \textbf{Aligned memory layout} optimised for CPU cache efficiency
    \item \textbf{Endian-aware serialisation} supporting both little and big-endian platforms
\end{itemize}

For complex data structures like 3D city models, FlatBuffers allows for modular schema composition through file inclusion. This capability enabled the separation of FlatCityBuf's schema into logical components (\texttt{header.fbs}, \texttt{feature.fbs}, \texttt{geometry.fbs}, etc.) while maintaining efficient serialisation. In our implementation, the \texttt{Header} and \texttt{CityFeature} tables serve as root types that anchor the overall data structure.
