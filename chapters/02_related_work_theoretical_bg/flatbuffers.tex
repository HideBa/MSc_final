%!TEX root = ../../thesis.tex

\section{FlatBuffers Framework}
\label{tb:flatbuffers}

FlatBuffers, developed by \citet{flatbuffers}, is a cross-platform serialisation framework designed specifically for performance-critical applications with a focus on memory efficiency and processing speed. Unlike traditional serialisation approaches, FlatBuffers implements a zero-copy deserialisation mechanism that enables direct access to serialised data without an intermediate parsing step \citep{flatbuffers_benchmark}, as discussed in \autoref{tb:zero_copy}.
This characteristic is particularly advantageous for large geospatial datasets, where parsing overhead can significantly impact performance (\eg, JSON parsing).

\subsection{Schema-Based Serialisation}
\label{tb:flatbuffers:schema_based_serialisation}

FlatBuffers employs a strongly typed, schema-based approach to data serialisation. The workflow involves:

\begin{enumerate}
  \item Definition of data structures in schema files with the \texttt{.fbs} extension
  \item Compilation of schema files using the FlatBuffers compiler (\texttt{flatc}) to generate language-specific code for data access
  \item Implementation of application logic using the generated code
\end{enumerate}

This schema-first approach enforces data consistency and type safety, which is essential to be processed in various programming languages and environments. The generated code provides memory-efficient access patterns to the underlying binary data without requiring full deserialisation. FlatCityBuf utilises this capability to achieve a balance between parsing speed and storage efficiency.

The FlatBuffers compiler supports code generation for multiple programming languages, including C++, Java, C\#, Go, Python, JavaScript, TypeScript, Rust, and others, facilitating cross-platform interoperability \citep{flatbuffers_support}. This extensive language support enables developers to work with FlatBuffers data in their preferred environment. For FlatCityBuf, Rust was selected as the primary implementation language due to its performance characteristics, memory safety guarantees, and excellent support for WebAssembly (WASM) compilation, which is beneficial for web-based deployment scenarios.

\subsection{Data Type System}
\label{tb:flatbuffers:data_type_system}

FlatBuffers provides a comprehensive type system that balances efficiency and expressiveness \citep{flatbuffers_data_types}:

\begin{itemize}
  \item \textbf{Tables}: Variable-sized object containers that support:
    \begin{itemize}
      \item Named fields with type annotations
      \item Optional fields with default values
      \item Schema evolution through backward compatibility
      \item Non-sequential field storage for memory optimisation
    \end{itemize}

  \item \textbf{Structs}: Fixed-size, inline aggregates that:
    \begin{itemize}
      \item Require all fields to be present (no optionality)
      \item Are stored directly within their containing object
      \item Are less flexible than tables but provide faster access
      \item Optimise memory layout for primitive types
    \end{itemize}
  \item \textbf{Scalar Types}: FlatBuffers supports a comprehensive range of primitive data types as shown in \autoref{tab:flatbuffers-scalar-types}.

    \begin{table}[htbp]
      \centering
      \caption{FlatBuffers Scalar Data Types}
      \label{tab:flatbuffers-scalar-types}
      \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Category} & \textbf{Type} & \textbf{Description} \\
        \hline
        8-bit integers & \texttt{byte} & Signed 8-bit integer (int8) \\
        & \texttt{ubyte} & Unsigned 8-bit integer (uint8) \\
        & \texttt{bool} & Boolean value \\
        \hline
        16-bit integers & \texttt{short} & Signed 16-bit integer (int16) \\
        & \texttt{ushort} & Unsigned 16-bit integer (uint16) \\
        \hline
        32-bit values & \texttt{int} & Signed 32-bit integer (int32) \\
        & \texttt{uint} & Unsigned 32-bit integer (uint32) \\
        & \texttt{float} & 32-bit floating-point number \\
        \hline
        64-bit values & \texttt{long} & Signed 64-bit integer (int64) \\
        & \texttt{ulong} & Unsigned 64-bit integer (uint64) \\
        & \texttt{double} & 64-bit floating-point number \\
        \hline
      \end{tabular}
    \end{table}

  \item \textbf{Complex Types}: FlatBuffers provides advanced data structures as outlined in \autoref{tab:flatbuffers-complex-types}.

    \begin{table}[htbp]
      \centering
      \caption{FlatBuffers Complex Data Types}
      \label{tab:flatbuffers-complex-types}
      \begin{tabular}{|l|l|}
        \hline
        \textbf{Type} & \textbf{Description} \\
        \hline
        \texttt{[T]} & Vectors (single-dimension arrays) of any supported type \\
        \hline
        \texttt{string} & UTF-8 or 7-bit ASCII encoded text with length prefix \\
        \hline
        References & References to other tables, structs, or unions \\
        \hline
      \end{tabular}
    \end{table}

  \item \textbf{Enums}: Type-safe constants mapped to underlying integer types
  \item \textbf{Unions}: Tagged unions supporting variant types
\end{itemize}

\subsection{Schema Organisation Features}
\label{tb:flatbuffers:schema_organisation}

In addition to the data type system, FlatBuffers provides several key features for organising complex schemas:

\begin{itemize}
  \item \textbf{Namespaces} (\texttt{namespace FlatCityBuf;}) create logical boundaries and prevent naming collisions

  \item \textbf{Include Mechanism} (\texttt{include "header.fbs";}) enables modular schema design across multiple files

  \item \textbf{Root Type} (\texttt{root\_type Header;}) identifies the primary table that serves as the entry point for buffer access
\end{itemize}

These features were essential for FlatCityBuf's implementation, enabling modular schema development with separate root types for header and feature components while maintaining consistent type definitions across files.

\subsection{Binary Structure and Memory Layout}
\label{tb:flatbuffers:binary_structure}
\todo{Ravi's comment "add a figure to illustrate a typical flatbuffer memory layout"}

FlatBuffers organises serialised data in a flat binary buffer with the following characteristics:

\begin{itemize}
  \item \textbf{Zero-copy access} through a carefully designed memory layout that allows direct access to serialized data without intermediate parsing
  \item \textbf{Vtable-based field access} where each table starts with an offset to its vtable, enabling efficient field lookup and schema evolution
  \item \textbf{Little-endian encoding} for all scalar values, with automatic conversion on big-endian platforms
  \item \textbf{Offset-based references} for all non-inline data (tables, strings, vectors), allowing efficient navigation within the buffer
\end{itemize}

\todo{add more detail for binary region refering to https://flatbuffers.dev/annotation/}

For complex data structures like 3D city models, FlatBuffers allows for modular schema composition through file inclusion. This capability enabled the separation of FlatCityBuf's schema into logical components (\texttt{header.fbs}, \texttt{feature.fbs}, \texttt{geometry.fbs}, etc.) while maintaining efficient serialisation. In our implementation, the \texttt{Header} and \texttt{CityFeature} tables serve as root types that anchor the overall data structure.
