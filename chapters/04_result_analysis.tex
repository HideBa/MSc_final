\chapter{Result}
\label{chp:result}

\section{Overview}
\label{result:overview}

This chapter presents the results of comprehensive evaluations conducted to assess the performance and suitability of the proposed FlatCitybuf format against existing CityJSON encoding approaches. The evaluation followed three complementary methodologies to provide a holistic understanding of the format's capabilities.

\subsection{Evaluation Methodology}
\label{result:overview:evaluation_methodology}

The assessment framework employed three distinct methodological approaches:

\subsubsection{File Size Comparison}
\label{result:overview:file_size_comparison}

\subsubsection{Local Benchmark Performance}
\label{result:overview:local_benchmark_performance}

Performance benchmarks were conducted on a laptop environment to evaluate the computational efficiency of the encoding format. These benchmarks measured:
\begin{itemize}
  \item Read operation time for files of varying sizes
  \item Memory consumption during processing operations
  \item Storage efficiency through file size comparisons
\end{itemize}

The benchmark utilised the datasets from \citet{ledoux_2024} and additional datasets from PLATEAU, providing direct comparability with previous studies on CityJSON and CityJSONSeq formats. All operations were conducted multiple times to ensure statistical reliability, with warm-up iterations to eliminate caching effects.

\subsubsection{Web-Based Performance}
\label{result:overview:web_based_performance}

To assess real-world application performance in cloud environments, web-based benchmarks were implemented using load testing frameworks to measure:
\begin{itemize}
  \item HTTP request-response cycle duration
  \item Effective throughput under various concurrent load scenarios
  \item Bandwidth utilisation, particularly for partial data retrieval operations
  \item Client-side rendering performance with progressive data loading
  \item Performance of HTTP Range requests for spatial and attribute queries
\end{itemize}

These measurements provide critical insights into the cloud optimisation benefits of the format, particularly regarding selective data retrieval and progressive rendering capabilities.

\subsubsection{System Architecture Analysis}
\label{result:overview:system_architecture_analysis}

A comparative analysis of system architectures evaluated how the proposed format affects:
\begin{itemize}
  \item Architectural complexity reduction potential
  \item Server-side resource requirements
  \item Client-side processing overhead
  \item Interoperability with existing GIS ecosystems
  \item Scalability characteristics for large datasets
\end{itemize}

This qualitative and quantitative analysis examines how the encoding format influences the overall system design, particularly focusing on cloud-based deployments and web mapping applications.

The following sections present detailed results from each evaluation approach, followed by integrated analyses that synthesise findings across methodologies to provide comprehensive insights into the performance characteristics of the FlatCitybuf format.

\section{File Size Comparison}
\label{result:file_size_comparison}

\subsubsection{Datasets}
\label{result:overview:dataset}
To evaluate file sizes and conduct both local and web-based benchmarks, we utilized various datasets from \citet{ledoux_2024} along with additional datasets from PLATEAU. Detailed information about these datasets and their attributions can be found in \autoref{appendix:dataset}.

\subsection{File size results}
\label{result:overview:filesize_comparison}

\autoref{tab:dataset_comparison} shows the datasets in both CityJSONSeq format and FlatCitybuf format. The result shows that FlatCityBuf encoding performed better for some datasets such as Helsinki, Ingolstadt, Montréal, and New York City. The compression factor for those cities are $16.36\%$, $19.09\%$, $-4.38\%$, and $20.17\%$ respectively. On the other hands, PLATEAU datasets show the opposite result, that is, CityJSONSeq format performed better for those datasets.

\begin{table*}
  \centering
  \begin{threeparttable}
    \caption{The datasets used for the benchmark.}
    \label{tab:dataset_comparison}
    \scriptsize
    \setlength{\tabcolsep}{4pt}
    \begin{tabular}{@{}lrrlrrr@{\hskip 3pt}rrrr@{}}
      \toprule
      & \multicolumn{3}{c}{\textbf{dataset}} & \multicolumn{3}{c}{\textbf{size of file}} & \multicolumn{4}{c}{\textbf{attributes}} \\
      \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-11}
      & CityObj & CityFeat & app.$^{\text{(a)}}$ & CityJSONSeq & FlatCityBuf & compr.$^{\text{(b)}}$ & verts & avg$^{\text{(c)}}$ & obj$^{\text{(d)}}$ & sem$^{\text{(e)}}$ \\
      \midrule
      \textbf{3DBAG}          & 2221    & 1110   &      & \qty{5.87}{\mega\byte}  & \qty{6.23}{\mega\byte}  & $-6.02\%$  & 82612    & 74.43    & 37 & 1 \\
      \textbf{3DBV}           & 71634   & 71634  &      & \qty{317.34}{\mega\byte}& \qty{280.92}{\mega\byte}& $11.48\%$  & 4992893  & 69.70    & 64 & 0 \\
      \textbf{Helsinki}       & 77267   & 77231  &      & \qty{412.44}{\mega\byte}& \qty{344.96}{\mega\byte}& $16.36\%$  & 3039107  & 39.35    & 27 & 9 \\
      \textbf{Helsinki\_tex}  & 77267   & 77231  & tex  & \qty{643.70}{\mega\byte}& \qty{545.29}{\mega\byte}& $15.29\%$  & 3039107  & 39.35    & 28 & 9 \\
      \textbf{Ingolstadt}     & 379     & 55     &      & \qty{3.84}{\mega\byte}  & \qty{3.11}{\mega\byte}  & $19.09\%$  & 88001    & 1600.02  & 33 & 13 \\
      \textbf{Montréal}       & 294     & 294    &      & \qty{4.60}{\mega\byte}  & \qty{4.80}{\mega\byte}  & $-4.38\%$  & 32242    & 109.67   & 0  & 0 \\
      \textbf{NYC}            & 23777   & 23777  &      & \qty{95.45}{\mega\byte} & \qty{76.20}{\mega\byte} & $20.17\%$  & 1044145  & 43.91    & 3  & 3 \\
      \textbf{Railway}        & 121     & 38     &      & \qty{4.05}{\mega\byte}  & \qty{3.75}{\mega\byte}  & $7.35\%$   & 73856    & 1943.58  & 3  & 0 \\
      \textbf{Rotterdam}      & 853     & 853    &      & \qty{2.69}{\mega\byte}  & \qty{2.80}{\mega\byte}  & $-3.98\%$  & 26679    & 31.28    & 5  & 0 \\
      \textbf{Vienna}         & 1322    & 307    &      & \qty{4.81}{\mega\byte}  & \qty{4.12}{\mega\byte}  & $14.32\%$  & 47229    & 153.84   & 7  & 4 \\
      \textbf{Zürich}         & 198699  & 52834  &      & \qty{247.12}{\mega\byte}& \qty{188.63}{\mega\byte}& $23.67\%$  & 3564542  & 67.47    & 8  & 0 \\
      \textbf{PLATEAU\_bldg}  & 10405   & 4307   &      & \qty{76.94}{\mega\byte} & \qty{79.41}{\mega\byte} & $-3.22\%$  & 147754   & 34.31    & 14 & 2 \\
      \textbf{PLATEAU\_brid}  & 60      & 8      &      & \qty{4.78}{\mega\byte}  & \qty{5.21}{\mega\byte}  & $-9.09\%$  & 16357    & 2044.62  & 5  & 2 \\
      \textbf{PLATEAU\_rwy}   & 412     & 412    &      & \qty{4.15}{\mega\byte}  & \qty{4.23}{\mega\byte}  & $-1.90\%$  & 5846     & 14.19    & 3  & 2 \\
      \textbf{PLATEAU\_tran}  & 8136    & 8136   &      & \qty{26.47}{\mega\byte} & \qty{26.62}{\mega\byte} & $-0.54\%$  & 45992    & 5.65     & 3  & 2 \\
      \textbf{PLATEAU\_tun}   & 21      & 3      &      & \qty{4.86}{\mega\byte}  & \qty{4.64}{\mega\byte}  & $4.41\%$   & 12306    & 4102.00  & 4  & 1 \\
      \textbf{PLATEAU\_veg}   & 936     & 936    &      & \qty{1.78}{\mega\byte}  & \qty{2.32}{\mega\byte}  & $-30.50\%$ & 2567     & 2.74     & 3  & 0 \\
      \textbf{Tokyo\_PLATEAU} & 49764   & 38627  &      & \qty{209.62}{\mega\byte}& \qty{216.76}{\mega\byte}& $-3.41\%$  & 316607   & 8.20     & 15 & 1 \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}[flushleft]
      \footnotesize
    \item[a] appearance: `tex' indicates textures are stored
    \item[b] compression factor is $\frac{\text{CityJSONSeq} - \text{FlatCityBuf}}{\text{CityJSONSeq}}$ (positive values indicate size reduction)
    \item[c] average number of vertices per feature
    \item[d] number of attributes in city objects
    \item[e] number of semantic surface attributes
    \end{tablenotes}
  \end{threeparttable}
\end{table*}

\subsection{Analysis of file size results}
\label{result:overview:analysis_of_file_size_results}
Although \autoref{result:overview:filesize_comparison} shows summary of the file size results, it's still not clear what effects on the resulting file size. Therefore, the section tries to analyse the possible cause by experimenting with simplier datasets.

\subsubsection{Level of detail}
\label{result:overview:analysis_of_file_size_results:level_of_detail}

To understand the impact of level of detail (LOD) on file size, a series of tests were conducted using the TU Delft BK building model at different LOD levels. Each LOD was manually extracted from the original model, and attributes and semantic attributes were deliberately deleted to simplify the problem and focus solely on geometric complexity. \autoref{tab:lod_comparison} presents the results of this analysis.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes across different levels of detail for the TU Delft BK building model.}
  \label{tab:lod_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression} & \textbf{Vertices} \\
    \midrule
    TUD BK All & \qty{139.75}{\kilo\byte} & \qty{189.01}{\kilo\byte} & $26.08\%$ & 4549 \\
    TUD BK LOD0 & \qty{12.77}{\kilo\byte} & \qty{20.72}{\kilo\byte} & $38.11\%$ & 785 \\
    TUD BK LOD1.2 & \qty{37.45}{\kilo\byte} & \qty{49.40}{\kilo\byte} & $24.23\%$ & 1350 \\
    TUD BK LOD1.3 & \qty{44.66}{\kilo\byte} & \qty{59.25}{\kilo\byte} & $24.67\%$ & 1600 \\
    TUD BK LOD2.2 & \qty{62.02} {\kilo\byte} & \qty{82.74}{\kilo\byte} & $25.07\%$ & 2168 \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$

  \end{tablenotes}
\end{table}

Note that because the given simple dataset only contains 1 city feature, we compare the bytes size of the feature rather than the entire file size. This is because FlatCityBuf tends to have a larger overall file size for tiny features due to its header part, which would skew the comparison if we looked at total file sizes.
The results show that while there is a natural increase in file size with higher levels of detail, there is actually not much correlation between LOD and compression efficiency. Both formats grow proportionally as geometric complexity increases. The compression advantage of FlatCityBuf over CityJSONSeq remains relatively stable across most LOD levels, typically around 24-25\%.

\subsubsection{Attributes}
\label{result:overview:analysis_of_file_size_results:attributes}

To analyze the impact of attributes on file size, tests were conducted using simple cube models from \citep{cityjson_dataset} with varying numbers of attributes. Attributes were randomly generated to the specified number for each test case. Both integer and string attributes were tested to understand how different data types affect compression. \autoref{tab:attribute_comparison} presents the results of this analysis.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes with varying numbers of attributes for simple cube models.}
  \label{tab:attribute_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression} & \textbf{Attributes} \\
    \midrule
    10 attributes (int) & \qty{580}{\byte} & \qty{611}{\byte} & $5.07\%$ & 10 \\
    100 attributes (int) & \qty{1.62}{\kilo\byte} & \qty{2.44}{\kilo\byte} & $33.65\%$ & 100 \\
    1000 attributes (int) & \qty{12.17}{\kilo\byte} & \qty{21.78}{\kilo\byte} & $44.13\%$ & 1000 \\
    10 attributes (string) & \qty{580}{\byte} & \qty{611}{\byte} & $5.07\%$ & 10 \\
    100 attributes (string) & \qty{1.62}{\kilo\byte} & \qty{2.44}{\kilo\byte} & $33.65\%$ & 100 \\
    1000 attributes (string) & \qty{12.17}{\kilo\byte} & \qty{21.78}{\kilo\byte} & $44.13\%$ & 1000 \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$
  \end{tablenotes}
\end{table}
The results demonstrate a distinct pattern: FlatCityBuf's compression advantage over CityJSONSeq grows substantially as the number of attributes increases. With just 10 attributes, the compression benefit is negligible at 5.07\%. This advantage rises significantly to 33.65\% with 100 attributes and reaches 44.13\% with 1000 attributes. This efficiency stems from FlatCityBuf's design, which stores the attribute schema once in the file header. Each feature then references attributes using only a 2-byte (u16) index, while CityJSONSeq must repeat identical attribute keys across all features. Although additional attributes increase the header size, this cost is distributed across all features in the dataset. The header remains compact—even with 1000 attributes, it occupies only a few tens of kilobytes. These characteristics make FlatCityBuf particularly well-suited for datasets containing numerous attributes.

\subsubsection{Geometric complexity}
\label{result:overview:analysis_of_file_size_results:geometric_complexity}

\subsubsection{Vertices and coordinates}
\label{result:overview:analysis_of_file_size_results:vertices_and_coordinates}

\section{Benchmark on Local Environment}
\label{result:benchmark_on_local_environment}

This section details the performance evaluation of the proposed FlatCitybuf format in a controlled local environment, focusing on read operations, memory consumption, and processing efficiency.

\subsection{Test Environment}
\label{result:benchmark_on_local_environment:test_environment}

All benchmarks were conducted on a consistent hardware and software configuration to ensure reliable and reproducible results:

\begin{itemize}
  \item \textbf{Hardware:} Apple MacBook Pro with M1 Max chip, 32GB unified memory
  \item \textbf{Operating System:} macOS Sequoia 15.4
  \item \textbf{Filesystem:} APFS (Apple File System)
  \item \textbf{Disk Configuration:} 1TB SSD with approximately 500GB free space
  \item \textbf{Runtime Environment:} Rust 1.75.0, with optimised release builds (-O3 optimisation)
\end{itemize}

To minimise environmental variables affecting the measurements, all tests were performed with:
\begin{itemize}
  \item Minimal background processes running
  \item No active network connections (except where required for web benchmarks)
  \item Consistent thermal conditions (ambient temperature and system cooling)
  \item Power connected to eliminate battery state influence
\end{itemize}

\subsection{Benchmark Methodology}
\label{result:benchmark_on_local_environment:benchmark_methodology}

The benchmark procedure followed a systematic approach to ensure measurement accuracy:

\begin{itemize}
  \item \textbf{Warm-up Phase:} Prior to measurement, each format underwent a 5-second warm-up period with repeated operations to ensure CPU caches were properly primed and JIT optimisations were applied

  \item \textbf{Measurement Iterations:} Each operation was executed 100 times consecutively, with measurements recorded for each iteration

  \item \textbf{Statistical Processing:} Measurements were processed to obtain mean values, standard deviations, and confidence intervals (95\%)

  \item \textbf{Process Isolation:} Each format test was run in a separate process to prevent cross-contamination of memory or cache state

  \item \textbf{File System Cache Control:} Between format tests, file system caches were cleared to ensure fair comparison of I/O performance
\end{itemize}

\subsection{Measurement Parameters}
\label{result:benchmark_on_local_environment:measurement_parameters}

The benchmark captured several key performance indicators:

\begin{itemize}
  \item \textbf{Read Time:} The duration required to deserialise the file and access the complete CityJSON structure, measured in milliseconds

  \item \textbf{Memory Consumption:} Peak Resident Set Size (RSS) during file processing, indicating the maximum memory footprint of the operation

  \item \textbf{CPU Utilisation:} Percentage of CPU resources consumed during the operation, measured as an average across the process lifetime

  \item \textbf{Storage Efficiency:} File size comparison between formats, measured in megabytes and percentage reduction relative to the original CityJSON format

  \item \textbf{Partial Data Access:} For formats supporting it, the time required to access specific city objects without loading the entire dataset
\end{itemize}

For each dataset, these parameters were measured across all encoding formats (CityJSON, CityJSONSeq, CBOR, BSON, and FlatCitybuf) to enable direct comparison. The following section presents the results of these measurements and analyses their implications for format performance.

\subsection{Read Performance Results}
\label{result:benchmark_on_local_environment:read_performance_results}

\subsection{Benchmark over the web}
\label{result:benchmark_on_local_environment:benchmark_over_the_web}

\subsection{System architecture review with proposed method and existing method}
\label{result:overview:system_architecture_review_with_proposed_method_and_existing_method}

\subsection{Performance evaluation}
\label{result:overview:performance_evaluation}

\subsection{Case study}
\label{result:overview:case_study}
