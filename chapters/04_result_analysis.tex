\chapter{Result}
\label{chp:result}
\section{Overview}
\label{result:overview}
This chapter presents comprehensive evaluations of the FlatCityBuf format, demonstrating its performance characteristics and practical applicability through multiple assessment approaches. The evaluation encompasses both technical performance metrics and real-world implementation scenarios to provide a holistic understanding of the format's capabilities.

The chapter is structured around several key evaluation components. First, a web prototype implementation is presented to demonstrate FlatCityBuf's practical capabilities in browser environments, showcasing how the format enables partial data access for large 3D city models through HTTP Range Requests.

Second, the datasets used throughout the evaluation are described, including both the established benchmark datasets from \citet{ledoux_2024} and additional PLATEAU datasets, providing context for the performance comparisons and ensuring reproducibility of results.

Third, file size comparisons are conducted across different encoding formats to evaluate storage efficiency and compression characteristics of FlatCityBuf relative to existing CityJSON variants.

Finally, web environment evaluations demonstrate real-world performance characteristics by measuring data retrieval times and network efficiency in browser-based scenarios. These tests specifically evaluate the effectiveness of HTTP Range Requests for selective data access, providing insights into bandwidth optimisation and response times critical for web-based 3D city model applications.

The following sections present detailed results from each evaluation component, culminating in integrated analyses that synthesise findings to provide comprehensive insights into FlatCityBuf's performance characteristics and practical benefits for 3D city model applications.

\subsection{Web Prototype}
\label{result:web_prototype}

\subsection{Cross-Platform Implementation}
\label{result:cross_platform_implementation}

FlatCityBuf provides range request capabilities across multiple platforms to maximise accessibility and integration options:
\subsubsection{Cross-Platform Support}
\label{result:cross_platform_implementation:cross_platform}

FlatCityBuf is implemented primarily as a Rust library that can be used in both native environments and web browsers. The same codebase is compiled to:

\begin{itemize}
  \item Native Rust library for server-side applications and desktop GIS tools
  \item WebAssembly (WASM) module for browser-based applications with JavaScript interoperability
\end{itemize}

This cross-platform approach enables FlatCityBuf to work with both Rust's native HTTP clients and browser-based Fetch API implementations. The WASM implementation has one notable limitation: current browser WebAssembly implementations use a 32-bit memory model (4GB limit), which may constrain processing of country-level datasets. This limitation will be resolved with the upcoming WebAssembly Memory64 proposal \citep{WebAssemblyCoreSpecification2}.
\subsubsection{Web prototype}
\label{result:cross_platform_implementation:web_prototype}

To demonstrate FlatCityBuf's capabilities in web environments and illustrate practical user interactions with the data, a functional web prototype was developed. The prototype is publicly accessible at \url{https://fcb-web-prototype.netlify.app/}. It leverages the WebAssembly module of FlatCityBuf combined with TypeScript and React for the frontend implementation, with Cesium serving as the 3D map rendering engine.

The prototype operates on a substantial dataset covering approximately 20km $\times$ 20km of South Holland, Netherlands, stored as a single 3.4GB FlatCityBuf file. This file is delivered directly from Google Cloud Storage\citep{gcs}, a serverless storage service, where it exists as a static file similar to images or videos, requiring no specialized server-side processing. Despite this large file size, the application remains responsive by utilising the HTTP range request capabilities described in \autoref{result:cross_platform_implementation:cloud_integration}. Users can interact with the data through several query mechanisms:

\begin{itemize}
  \item \textbf{Spatial queries}: Users can filter features either by defining a spatial bounding box or by placing a point on the map to retrieve features based on intersection or nearest-neighbor relationships.

  \item \textbf{Attribute queries}: The interface supports filtering features through attribute conditions (\eg, \texttt{building id = 1, height > 10m}), demonstrating the attribute index capabilities.

  \item \textbf{Data export}: Users can download the filtered subset of features in CityJSONSeq format, showcasing the format conversion capabilities.
\end{itemize}

This prototype effectively demonstrates how FlatCityBuf enables browser-based applications to work with large 3D city models without downloading the entire dataset, providing responsive performance even on consumer-grade hardware and network connections.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{figs/result_analysis/web_prototype.png}
  \caption{Web prototype of FlatCityBuf demonstrating spatial and attribute query capabilities on a 3.4GB dataset of South Holland.}
  \label{fig:result:cross_platform_implementation:web_prototype}
\end{figure}

\subsection{Integration with Cloud Infrastructure}
\label{result:cross_platform_implementation:cloud_integration}

The HTTP Range Request mechanism integrates seamlessly with modern cloud infrastructure. FlatCityBuf files can be served from standard object storage services like AWS S3, Google Cloud Storage, or Azure Blob Storage, all of which support range requests without additional server-side processing. This enables a serverless architecture where the client-side filtering approach eliminates the need for dedicated server-side processing. This infrastructure compatibility ensures that FlatCityBuf can be deployed in cost-effective cloud environments without requiring specialised application servers and databases.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{figs/result_analysis/server_architecture_fcb.png}
  \caption{Server architecture for FlatCityBuf. The client-side filtering approach eliminates the need for dedicated server-side processing.}
  \label{fig:result:cross_platform_implementation:server_architecture}
\end{figure}
\section{Datasets}
\label{result:dataset}

To evaluate file sizes and conduct both local and web-based benchmarks, we employed a diverse range of datasets from \citet{ledoux_2024} supplemented with additional datasets from PLATEAU \citep{plateau}. PLATEAU employs its own data specification combining CityGML 2.0 \citep{CityGML} with a custom \ac{ade}. The CityGML-encoded 3D city models were converted to CityJSON using citygml-tools, a command-line utility developed by \citet{citygml_tools}. Note that PLATEAU's \ac{ade} components are not included in the converted datasets since they are not compatible with the current CityJSON implementation.

To comprehensively evaluate FlatCityBuf, we utilised diverse PLATEAU models including buildings, bridges, transport, tunnels, and vegetation. The dataset collection spans various urban environments from small-scale architectural models to large metropolitan areas across European and Japanese cities, enabling evaluation across different feature types, geometric complexities, and data modeling approaches. Comprehensive information regarding these datasets and their attributions is provided in \autoref{appendix:dataset}.

\section{File Size Comparison}
\label{result:file_size_comparison}

\subsection{File size results}
\label{result:overview:filesize_comparison}

\autoref{tab:dataset_comparison} presents a comparison of datasets in both CityJSONSeq and FlatCityBuf formats. The results demonstrate that FlatCityBuf encoding achieves superior compression for several datasets, including Helsinki, Ingolstadt, and New York City, with compression factors of 16.36\%, 19.09\%, and 20.17\% respectively. Conversely, the PLATEAU datasets exhibit the opposite trend, with CityJSONSeq format demonstrating better storage efficiency.

\todo{Add whole 3DBAG}
\begin{table*}
  \centering
  \begin{threeparttable}
    \caption{The datasets used for the benchmark.}
    \label{tab:dataset_comparison}
    \scriptsize
    \setlength{\tabcolsep}{4pt}
    \begin{tabular}{@{}lrrlrrr@{\hskip 3pt}rrrr@{}}
      \toprule
      & \multicolumn{3}{c}{\textbf{dataset}} & \multicolumn{3}{c}{\textbf{size of file}} & \multicolumn{4}{c}{\textbf{attributes}} \\
      \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-11}
      & CityObj & CityFeat & app.$^{\text{(a)}}$ & CityJSONSeq & FlatCityBuf & compr.$^{\text{(b)}}$ & verts & avg$^{\text{(c)}}$ & obj$^{\text{(d)}}$ & sem$^{\text{(e)}}$ \\
      \midrule
      \textbf{3DBAG}          & 2221    & 1110   &      & \qty{5.87}{\mega\byte}  & \qty{6.23}{\mega\byte}  & $-6.02\%$  & 82612    & 74.43    & 37 & 1 \\
      \textbf{3DBV}           & 71634   & 71634  &      & \qty{317.34}{\mega\byte}& \qty{280.92}{\mega\byte}& $11.48\%$  & 4992893  & 69.70    & 64 & 0 \\
      \textbf{Helsinki}       & 77267   & 77231  &      & \qty{412.44}{\mega\byte}& \qty{344.96}{\mega\byte}& $16.36\%$  & 3039107  & 39.35    & 27 & 9 \\
      \textbf{Helsinki\_tex}  & 77267   & 77231  & tex  & \qty{643.70}{\mega\byte}& \qty{545.29}{\mega\byte}& $15.29\%$  & 3039107  & 39.35    & 28 & 9 \\
      \textbf{Ingolstadt}     & 379     & 55     &      & \qty{3.84}{\mega\byte}  & \qty{3.11}{\mega\byte}  & $19.09\%$  & 88001    & 1600.02  & 33 & 13 \\
      \textbf{Montréal}       & 294     & 294    & tex  & \qty{4.60}{\mega\byte}  & \qty{4.80}{\mega\byte}  & $-4.38\%$  & 32242    & 109.67   & 0  & 0 \\
      \textbf{NYC}            & 23777   & 23777  &      & \qty{95.45}{\mega\byte} & \qty{76.20}{\mega\byte} & $20.17\%$  & 1044145  & 43.91    & 3  & 3 \\
      \textbf{Rotterdam}      & 853     & 853    & tex  & \qty{2.69}{\mega\byte}  & \qty{2.80}{\mega\byte}  & $-3.98\%$  & 26679    & 31.28    & 5  & 0 \\
      \textbf{Vienna}         & 1322    & 307    &      & \qty{4.81}{\mega\byte}  & \qty{4.12}{\mega\byte}  & $14.32\%$  & 47229    & 153.84   & 7  & 4 \\
      \textbf{Zürich}         & 198699  & 52834  &      & \qty{247.12}{\mega\byte}& \qty{188.63}{\mega\byte}& $23.67\%$  & 3564542  & 67.47    & 8  & 0 \\
      \textbf{PLATEAU\_bldg}  & 10405   & 4307   &      & \qty{76.94}{\mega\byte} & \qty{79.41}{\mega\byte} & $-3.22\%$  & 147754   & 34.31    & 14 & 2 \\
      \textbf{PLATEAU\_brid}  & 60      & 8      &      & \qty{4.78}{\mega\byte}  & \qty{5.21}{\mega\byte}  & $-9.09\%$  & 16357    & 2044.62  & 5  & 2 \\
      \textbf{PLATEAU\_rwy}   & 412     & 412    &      & \qty{4.15}{\mega\byte}  & \qty{4.23}{\mega\byte}  & $-1.90\%$  & 5846     & 14.19    & 3  & 2 \\
      \textbf{PLATEAU\_tran}  & 8136    & 8136   &      & \qty{26.47}{\mega\byte} & \qty{26.62}{\mega\byte} & $-0.54\%$  & 45992    & 5.65     & 3  & 2 \\
      \textbf{PLATEAU\_tun}   & 21      & 3      &      & \qty{4.86}{\mega\byte}  & \qty{4.64}{\mega\byte}  & $4.41\%$   & 12306    & 4102.00  & 4  & 1 \\
      \textbf{PLATEAU\_veg}   & 936     & 936    &      & \qty{1.78}{\mega\byte}  & \qty{2.32}{\mega\byte}  & $-30.50\%$ & 2567     & 2.74     & 3  & 0 \\
      \textbf{Tokyo\_PLATEAU} & 49764   & 38627  &      & \qty{209.62}{\mega\byte}& \qty{216.76}{\mega\byte}& $-3.41\%$  & 316607   & 8.20     & 15 & 1 \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}[flushleft]
      \footnotesize
    \item[a] appearance: `tex' indicates textures are stored; `mat' indicates materials are stored
    \item[b] compression factor is $\frac{\text{CityJSONSeq} - \text{FlatCityBuf}}{\text{CityJSONSeq}}$ (positive values indicate size reduction)
    \item[c] average number of vertices per feature
    \item[d] number of attributes in city objects
    \item[e] number of semantic surface attributes in city objects
    \end{tablenotes}
  \end{threeparttable}
\end{table*}

\subsection{Analysis of file size results}
\label{result:overview:analysis_of_file_size_results}
Although \autoref{result:overview:filesize_comparison} provides a summary of file size comparisons, the factors influencing these outcomes require further investigation. This section analyses the underlying causes through controlled experiments with simplified datasets.

\subsubsection{Level of detail}
\label{result:overview:analysis_of_file_size_results:level_of_detail}

To examine how level of detail (LOD) affects file size, I conducted a series of tests using the TU Delft BK building model at various LOD levels. Each LOD variant was systematically extracted from the original model, with attributes and semantic information deliberately removed to isolate the effect of geometric complexity. \autoref{tab:lod_comparison} presents the results of this analysis.

Since each test dataset contains only a single city feature, we compare feature sizes rather than total file sizes. This approach is necessary because FlatCityBuf incorporates a larger header structure, which would disproportionately affect comparisons involving minimal features.

The results demonstrate that while file sizes increase with higher levels of detail, the compression factor remains largely independent of LOD. Both formats show similar proportional growth in size as geometric complexity increases, with FlatCityBuf consistently achieving approximately 24-25\% size reduction compared to CityJSONSeq regardless of the LOD level. This suggests that the compression efficiency is determined by the underlying format design rather than the geometric complexity of the data.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes across different levels of detail for the TU Delft BK building model.}
  \label{tab:lod_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression} & \textbf{Vertices} \\
    \midrule
    TUD BK All & \qty{139.75}{\kilo\byte} & \qty{189.01}{\kilo\byte} & $26.08\%$ & 4549 \\
    TUD BK LOD0 & \qty{12.77}{\kilo\byte} & \qty{20.72}{\kilo\byte} & $38.11\%$ & 785 \\
    TUD BK LOD1.2 & \qty{37.45}{\kilo\byte} & \qty{49.40}{\kilo\byte} & $24.23\%$ & 1350 \\
    TUD BK LOD1.3 & \qty{44.66}{\kilo\byte} & \qty{59.25}{\kilo\byte} & $24.67\%$ & 1600 \\
    TUD BK LOD2.2 & \qty{62.02} {\kilo\byte} & \qty{82.74}{\kilo\byte} & $25.07\%$ & 2168 \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$

  \end{tablenotes}
\end{table}

\subsubsection{Attributes}
\label{result:overview:analysis_of_file_size_results:attributes}

To assess the impact of attributes on file size, we tested simple cube models from \citep{cityjson_dataset} with varying numbers of attributes. We systematically generated random attributes for each test case, examining both integer and string data types to determine their effect on compression efficiency. \autoref{tab:attribute_comparison} presents the results of this analysis.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes with varying numbers of attributes for simple cube models.}
  \label{tab:attribute_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression}  \\
    \midrule
    10 attributes (int) & \qty{580}{\byte} & \qty{611}{\byte} & $5.07\%$ \\
    100 attributes (int) & \qty{1.62}{\kilo\byte} & \qty{2.44}{\kilo\byte} & $33.65\%$ \\
    1000 attributes (int) & \qty{12.17}{\kilo\byte} & \qty{21.78}{\kilo\byte} & $44.13\%$ \\
    10 attributes (string) & \qty{580}{\byte} & \qty{611}{\byte} & $5.07\%$ \\
    100 attributes (string) & \qty{1.62}{\kilo\byte} & \qty{2.44}{\kilo\byte} & $33.65\%$ \\
    1000 attributes (string) & \qty{12.17}{\kilo\byte} & \qty{21.78}{\kilo\byte} & $44.13\%$ \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$
  \end{tablenotes}
\end{table}

The randomly generated attributes in our test datasets followed a consistent pattern, as shown in the example below:

\begin{verbatim}
{
  "type": "Building",
  "geometry": [...],
  "attributes": {
    "attr_1": "value_1",
    "attr_2": "value_2",
    "attr_3": "value_3",
    "attr_4": "value_4",
    "attr_5": "value_5",
    ...
    "attr_n": "value_n"
  }
}
\end{verbatim}

For integer attribute tests, all values were randomly generated integers between 0 and 1000. For string attribute tests, values were randomly generated strings of varying lengths between 5 and 15 characters. This approach ensured a realistic representation of typical attribute data while maintaining controlled test conditions.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.48\textwidth]{figs/result_analysis/cube.png}
  \caption{Simple cube model used for attribute testing. This basic geometric structure provides a controlled environment for evaluating the impact of attributes on file size.}
  \label{fig:simple_cube}
\end{figure}

The results reveal a clear pattern: FlatCityBuf's compression advantage over CityJSONSeq increases substantially with the number of attributes. With only 10 attributes, the compression benefit is minimal at 5.07\%, but rises markedly to 33.65\% with 100 attributes and reaches 44.13\% with 1000 attributes.

This efficiency stems from FlatCityBuf's architectural design, which stores the attribute schema once in the file header. Each feature subsequently references attributes using only a 2-byte (u16) index, while CityJSONSeq must replicate identical attribute keys across all features. Although additional attributes increase the header size, this overhead is distributed across all features in the dataset. The header remains relatively compact—even with 1000 attributes, it occupies only a few tens of kilobytes.

These characteristics render FlatCityBuf particularly advantageous for datasets containing numerous attributes. The same efficiency applies to semantic surface attributes, where the schema-based approach provides similar compression benefits when features contain multiple surfaces with rich semantic information.

\subsubsection{Geometry complexity}
\label{result:overview:analysis_of_file_size_results:geometric_complexity}

To evaluate how geometric complexity influences file size, we analysed models with varying numbers of vertices. The test utilised two geometrically distinct models from the TU Delft campus dataset—one simple and one complex. To isolate the effect of geometry, attributes and semantic information were removed, leaving only the essential geometric components required by CityJSON. \autoref{tab:geometry_comparison} presents the numerical results of this analysis, while \autoref{fig:geometry_comparison} provides visual comparisons of the models.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes with varying geometric complexity.}
  \label{tab:geometry_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression} & \textbf{Vertices/Feature} \\
    \midrule
    TUD BK & \qty{139.75}{\kilo\byte} & \qty{189.01}{\kilo\byte} & $26.06\%$ & 4549 \\
    TUD Simple & \qty{13.12}{\kilo\byte} & \qty{15.42}{\kilo\byte} & $14.94\%$ & 340 \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$
  \end{tablenotes}
\end{table}

\begin{figure}[htbp]
  \centering
  \begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/result_analysis/tud_simple.png}
    \caption{TUD Simple model (340 vertices/feature)}
    \label{fig:tud_simple}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{figs/result_analysis/tud_bk.png}
    \caption{TUD BK model (4549 vertices/feature)}
    \label{fig:tud_bk}
  \end{subfigure}
  \caption{Visual comparison of models with different geometric complexity.}
  \label{fig:geometry_comparison}
\end{figure}

The results demonstrate that geometric complexity significantly affects compression efficiency, with FlatCityBuf achieving better compression for more intricate models. The TU Delft BK building model, containing 4549 vertices per feature, exhibits a higher compression rate of 26.06\% compared to the simpler model with 340 vertices at 14.94\%.

This differential appears to result from the expanding boundary field as geometry becomes more complex. FlatCityBuf employs a strongly typed representation of boundaries (using u32 integers) that maintains a constant size for encoding each vertex, whereas CityJSONSeq requires additional bytes due to its text-based format. This fundamental difference in geometry encoding becomes increasingly advantageous for FlatCityBuf as geometric complexity rises.

\subsubsection{Vertices and coordinates}
\label{result:overview:analysis_of_file_size_results:vertices_and_coordinates}

To investigate how coordinate scale affects file size, I conducted tests using identical cube geometries with different coordinate magnitudes. All test models represent the same simple cube shape with identical geometric complexity (8 vertices per feature), but the coordinate values are scaled to different magnitudes—ranging from single digits to millions—while maintaining the same spatial relationships. \autoref{tab:vertices_comparison} presents the results of this analysis, utilising the same base cube geometry as in \autoref{result:overview:analysis_of_file_size_results:attributes}.

\begin{table}[htbp]
  \centering
  \caption{Comparison of file sizes with varying coordinate scales.}
  \label{tab:vertices_comparison}
  \begin{tabular}{@{}lrrrr@{}}
    \toprule
    \textbf{Dataset} & \textbf{FlatCityBuf}$^{\text{(a)}}$ & \textbf{CityJSONSeq}$^{\text{(b)}}$ & \textbf{Compression} & \textbf{Scale} \\
    \midrule
    Cube (1) & \qty{476}{\byte} & \qty{370}{\byte} & $-28.65\%$ & 1 \\
    Cube (10) & \qty{476}{\byte} & \qty{459}{\byte} & $-3.70\%$ & 10 \\
    Cube (1k) & \qty{476}{\byte} & \qty{507}{\byte} & $6.11\%$ & 1,000 \\
    Cube (1M) & \qty{476}{\byte} & \qty{579}{\byte} & $17.79\%$ & 1,000,000 \\
    \bottomrule
  \end{tabular}
  \begin{tablenotes}[flushleft]
    \footnotesize
  \item[a] Average feature size in bytes in FlatCityBuf: $\frac{\text{Total FlatCityBuf size}}{\text{Number of features}}$
  \item[b] Average feature size in bytes in CityJSONSeq: $\frac{\text{Total CityJSONSeq size}}{\text{Number of features}}$
  \end{tablenotes}
\end{table}

The results reveal an intriguing relationship between coordinate scale and file size in both formats. FlatCityBuf maintains a consistent size of 476 bytes regardless of coordinate magnitude, demonstrating its fixed-size binary encoding for numeric values. In contrast, CityJSONSeq's file size increases proportionally with larger coordinate values, growing from 370 bytes with single-digit coordinates to 579 bytes with million-scale coordinates.

This behaviour occurs because both FlatCityBuf and CityJSONSeq use integer values as coordinates, which are quantised by the \texttt{Transform} field as explained in \autoref{rw:cityjson:coordinate_quantisation}. However, FlatCityBuf stores these coordinates as fixed-size 32-bit integers, while CityJSONSeq, being a text-based format, requires more characters to represent larger numbers. Consequently, FlatCityBuf transitions from being less efficient than CityJSONSeq for small coordinate values (-28.65\%) to substantially more efficient for large coordinate values (17.79\%).

This characteristic explains the pattern observed in \autoref{result:overview:filesize_comparison}. FlatCityBuf demonstrates lower storage efficiency for PLATEAU datasets, likely because these datasets employ geographic coordinate systems with values typically between -180 and 180. Since CityJSON quantises coordinates through the \texttt{Transform} field, latitude and longitude values can be represented as relatively small integers. Conversely, datasets where FlatCityBuf performs better—such as NYC and Helsinki—use local coordinate systems (in metres) with larger internal values, resulting in improved compression efficiency with FlatCityBuf.

\subsubsection{Summary of File Size Analysis}
\label{result:overview:analysis_of_file_size_results:summary}

The comprehensive analysis of various factors affecting file size reveals distinct patterns in the compression performance of FlatCityBuf compared to CityJSONSeq:

\begin{itemize}
  \item \textbf{Level of Detail:} The analysis demonstrates that geometric detail levels have minimal impact on compression efficiency. While file sizes naturally increase with higher LODs, the compression advantage of FlatCityBuf remains relatively consistent at approximately 24-25\% across different levels of geometric complexity.

  \item \textbf{Attribute Quantity:} The number of attributes significantly influences compression performance. FlatCityBuf's efficiency increases dramatically with attribute count, from minimal compression (5.07\%) with 10 attributes to substantial compression (44.13\%) with 1000 attributes. This progressive advantage stems from FlatCityBuf's schema-based approach that eliminates redundant attribute key storage.

  \item \textbf{Geometric Complexity:} More intricate geometries benefit from improved compression with FlatCityBuf. As boundary fields expand with geometric complexity, FlatCityBuf's fixed-size numeric representation provides greater efficiency compared to the text-based encoding of CityJSONSeq, increasing compression from 14.94\% for simple geometries to 26.06\% for complex models.

  \item \textbf{Coordinate Scale:} The magnitude of coordinate values has a significant impact on compression efficiency. FlatCityBuf's constant-size integer representation maintains consistent file sizes regardless of coordinate scale, while CityJSONSeq requires more space for larger values. This creates a transition from inferior compression (-28.65\%) with small coordinate values to superior compression (17.79\%) with large coordinate values.
\end{itemize}

These findings elucidate the observed variations in compression performance across different datasets in \autoref{tab:dataset_comparison}. FlatCityBuf demonstrates optimal performance for datasets with numerous attributes, complex geometries, and large-scale coordinate systems, while CityJSONSeq may retain advantages for simpler datasets with limited attributes and smaller coordinate values.

\section{Benchmark on Local Environment}
\label{result:benchmark_on_local_environment}

This section presents a comprehensive performance evaluation of the FlatCityBuf format conducted in a controlled local environment. The analysis focuses on critical metrics including read operations, memory utilisation, and processing efficiency to establish a thorough understanding of the format's performance characteristics.

\subsection{Test Environment}
\label{result:benchmark_on_local_environment:test_environment}

All benchmarks were executed within a consistent hardware and software configuration to ensure reliability and reproducibility:

\begin{itemize}
  \item \textbf{Hardware:} Apple MacBook Pro with M1 Max chip, 32GB unified memory
  \item \textbf{Operating System:} macOS Sequoia 15.4
  \item \textbf{Filesystem:} APFS (Apple File System)
  \item \textbf{Storage:} 1TB SSD with approximately 200GB available capacity
  \item \textbf{Runtime Environment:} Rust 1.86.0, with optimised release builds
\end{itemize}

\subsection{Measurement Parameters}
\label{result:benchmark_on_local_environment:measurement_parameters}

The benchmark framework captured multiple performance dimensions through the following key indicators:
\todo{Ravi's comment "you could also look at write performance here"}

\begin{itemize}
  \item \textbf{Read Performance:} Time required to deserialise the file and map the data into memory using zero-copy techniques, measured in milliseconds with microsecond precision

  \item \textbf{Memory Efficiency:} Peak Resident Set Size (RSS) during file processing, providing an accurate measurement of maximum memory requirements

\end{itemize}

These parameters were systematically measured across all encoding formats-CityJSONSeq, CBOR, BSON, and FlatCityBuf—to facilitate direct performance comparisons. \todo{Ravi's comment "why these and not others?"} The subsequent sections present a detailed analysis of these measurements and their implications for practical applications.

\subsubsection{Read Performance FlatCityBuf vs CityJSONSeq}
\label{result:benchmark_on_local_environment:read_performance_flatcitybuf_vs_cityjsonseq}

The performance comparison between FlatCityBuf and CityJSONSeq was conducted across multiple datasets, measuring processing time, and memory consumption as key metrics. \autoref{tab:performance_comparison} presents these results.

\begin{table}[ht]
  \centering
  \begin{threeparttable}
    \caption{Performance comparison between CityJSONSeq and FlatCityBuf}
    \label{tab:performance_comparison}
    \setlength{\tabcolsep}{6pt}
    \tiny
    \begin{tabular}{@{}l|rrr|rrr@{}}
      \toprule
      & \multicolumn{3}{c|}{\textbf{Processing Time}}
      & \multicolumn{3}{c}{\textbf{Memory Consumption}} \\
      \cmidrule(lr){2-4} \cmidrule(lr){5-7}
      \textbf{Dataset}
      & \textbf{CityJSONSeq} & \textbf{FlatCityBuf} & \textbf{Ratio\tnote{a}}
      & \textbf{CityJSONSeq} & \textbf{FlatCityBuf} & \textbf{Ratio\tnote{a}} \\
      \midrule
      3DBAG
      & \qty{54}{\milli\second} & \qty{6}{\milli\second} & 9.0$\times$
      & \qty{25.7}{\mega\byte} & \qty{5.4}{\mega\byte} & 4.7$\times$ \\

      3DBV
      & \qty{3.79}{\second} & \qty{120}{\milli\second} & 31.6$\times$
      & \qty{352.4}{\mega\byte} & \qty{59.0}{\mega\byte} & 6.0$\times$ \\

      Helsinki
      & \qty{3.49}{\second} & \qty{127}{\milli\second} & 27.4$\times$
      & \qty{16.1}{\mega\byte} & \qty{4.7}{\mega\byte} & 3.4$\times$ \\

      Ingolstadt
      & \qty{37}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{36.0}{\mega\byte} & \qty{9.0}{\mega\byte} & 4.0$\times$ \\

      Montréal
      & \qty{50}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{41.4}{\mega\byte} & \qty{10.4}{\mega\byte} & 4.0$\times$ \\

      NYC
      & \qty{949}{\milli\second} & \qty{42}{\milli\second} & 22.6$\times$
      & \qty{22.7}{\mega\byte} & \qty{6.6}{\mega\byte} & 3.4$\times$ \\

      Rotterdam
      & \qty{21}{\milli\second} & \qty{1}{\milli\second} & 21.0$\times$
      & \qty{10.8}{\mega\byte} & \qty{4.3}{\mega\byte} & 2.5$\times$ \\

      Vienna
      & \qty{46}{\milli\second} & \qty{1}{\milli\second} & 46.0$\times$
      & \qty{18.7}{\mega\byte} & \qty{5.7}{\mega\byte} & 3.3$\times$ \\

      Zürich
      & \qty{1.88}{\second} & \qty{149}{\milli\second} & 12.6$\times$
      & \qty{31.2}{\mega\byte} & \qty{5.9}{\mega\byte} & 5.3$\times$ \\

      Tokyo (PLATEAU)
      & \qty{1.95}{\second} & \qty{94}{\milli\second} & 20.8$\times$
      & \qty{71.9}{\mega\byte} & \qty{14.9}{\mega\byte} & 4.8$\times$ \\

      PLATEAU\_brid
      & \qty{89}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{80.3}{\mega\byte} & \qty{19.2}{\mega\byte} & 4.2$\times$ \\

      PLATEAU\_rwy
      & \qty{38}{\milli\second} & \qty{2}{\milli\second} & 19.0$\times$
      & \qty{16.8}{\mega\byte} & \qty{4.7}{\mega\byte} & 3.6$\times$ \\

      PLATEAU\_tran
      & \qty{259}{\milli\second} & \qty{14}{\milli\second} & 18.5$\times$
      & \qty{76.7}{\mega\byte} & \qty{23.0}{\mega\byte} & 3.3$\times$ \\

      PLATEAU\_tun
      & \qty{50}{\milli\second} & \qty{2}{\milli\second} & 25.0$\times$
      & \qty{81.8}{\mega\byte} & \qty{14.2}{\mega\byte} & 5.8$\times$ \\

      PLATEAU\_veg
      & \qty{900}{\milli\second} & \qty{33}{\milli\second} & 27.3$\times$
      & \qty{197.5}{\mega\byte} & \qty{70.4}{\mega\byte} & 2.8$\times$ \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}[flushleft]
      \footnotesize
    \item[a] Ratio = CityJSONSeq metric / FlatCityBuf metric (higher values indicate better FlatCityBuf performance)
    \item[b] Time recorded as 0 ms due to measurement precision limitations for very fast operations
    \end{tablenotes}
  \end{threeparttable}
\end{table}

\todo{Check if the memory consumption is correct. Also take benchmark on better environment}

The performance comparison reveals significant advantages for FlatCityBuf across multiple metrics. Processing time shows even more dramatic improvements, with FlatCityBuf consistently processing data between 8× and 46× faster than CityJSONSeq. Memory consumption results are mixed, with FlatCityBuf showing notable advantages for some datasets (particularly 3DBAG and Tokyo PLATEAU) while requiring slightly more memory for others.

\subsubsection{Read performance FlatCityBuf vs CBOR}
\label{result:benchmark_on_local_environment:read_performance_flatcitybuf_vs_cbor}

The performance comparison between FlatCityBuf and CBOR was conducted using the same datasets and measurement methodology. \autoref{tab:performance_comparison_cbor} presents these results.

\begin{table}[ht]
  \centering
  \begin{threeparttable}
    \caption{Performance comparison between CBOR and FlatCityBuf}
    \label{tab:performance_comparison_cbor}
    \setlength{\tabcolsep}{6pt}
    \tiny
    \begin{tabular}{@{}l|rrr|rrr@{}}
      \toprule
      & \multicolumn{3}{c|}{\textbf{Processing Time}}
      & \multicolumn{3}{c}{\textbf{Memory Consumption}} \\
      \cmidrule(lr){2-4} \cmidrule(lr){5-7}
      \textbf{Dataset}
      & \textbf{CBOR} & \textbf{FlatCityBuf} & \textbf{Ratio\tnote{a}}
      & \textbf{CBOR} & \textbf{FCB} & \textbf{Ratio\tnote{a}} \\
      \midrule
      3DBAG
      & \qty{73}{\milli\second} & \qty{6}{\milli\second} & 12.2$\times$
      & \qty{263.4}{\mega\byte} & \qty{5.4}{\mega\byte} & 48.6$\times$ \\

      3DBV
      & \qty{5.05}{\second} & \qty{120}{\milli\second} & 42.1$\times$
      & \qty{6.7}{\giga\byte} & \qty{59.0}{\mega\byte} & 116.6$\times$ \\

      Helsinki
      & \qty{6.31}{\second} & \qty{127}{\milli\second} & 49.6$\times$
      & \qty{7.0}{\giga\byte} & \qty{4.7}{\mega\byte} & 1521.5$\times$ \\

      Ingolstadt
      & \qty{46}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{219.7}{\mega\byte} & \qty{9.0}{\mega\byte} & 24.4$\times$ \\

      Montréal
      & \qty{59}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{304.6}{\mega\byte} & \qty{10.4}{\mega\byte} & 29.2$\times$ \\

      NYC
      & \qty{1.40}{\second} & \qty{42}{\milli\second} & 33.2$\times$
      & \qty{1.7}{\giga\byte} & \qty{6.6}{\mega\byte} & 262.2$\times$ \\

      Rotterdam
      & \qty{31}{\milli\second} & \qty{1}{\milli\second} & 31.0$\times$
      & \qty{206.0}{\mega\byte} & \qty{4.3}{\mega\byte} & 47.8$\times$ \\

      Vienna
      & \qty{59}{\milli\second} & \qty{1}{\milli\second} & 59.0$\times$
      & \qty{221.4}{\mega\byte} & \qty{5.7}{\mega\byte} & 38.6$\times$ \\

      Zürich
      & \qty{3.44}{\second} & \qty{149}{\milli\second} & 23.1$\times$
      & \qty{4.6}{\giga\byte} & \qty{5.9}{\mega\byte} & 792.5$\times$ \\

      Tokyo (PLATEAU)
      & \qty{3.12}{\second} & \qty{94}{\milli\second} & 33.2$\times$
      & \qty{4.1}{\giga\byte} & \qty{14.9}{\mega\byte} & 284.3$\times$ \\

      PLATEAU\_brid
      & \qty{71}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{287.3}{\mega\byte} & \qty{19.2}{\mega\byte} & 15.0$\times$ \\

      PLATEAU\_rwy
      & \qty{47}{\milli\second} & \qty{2}{\milli\second} & 23.5$\times$
      & \qty{112.2}{\mega\byte} & \qty{4.7}{\mega\byte} & 24.1$\times$ \\

      PLATEAU\_tran
      & \qty{344}{\milli\second} & \qty{14}{\milli\second} & 24.6$\times$
      & \qty{562.6}{\mega\byte} & \qty{23.0}{\mega\byte} & 24.4$\times$ \\

      PLATEAU\_tun
      & \qty{156}{\milli\second} & \qty{2}{\milli\second} & 78.0$\times$
      & \qty{389.6}{\mega\byte} & \qty{14.2}{\mega\byte} & 27.4$\times$ \\

      PLATEAU\_veg
      & \qty{1.06}{\second} & \qty{33}{\milli\second} & 32.0$\times$
      & \qty{1.7}{\giga\byte} & \qty{70.4}{\mega\byte} & 25.2$\times$ \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}[flushleft]
      \footnotesize
    \item[a] Ratio = CBOR metric / FlatCityBuf metric (higher values indicate better FlatCityBuf performance)
    \item[b] Time recorded as 0 ms due to measurement precision limitations for very fast operations
    \end{tablenotes}
  \end{threeparttable}
\end{table}

\todo{write something about the results. Also take benchmark on better environment}

\subsubsection{Read performance FlatCityBuf vs BSON}
\label{result:benchmark_on_local_environment:read_performance_flatcitybuf_vs_bson}

The performance comparison between FlatCityBuf and BSON followed the same methodology as the previous comparisons. \autoref{tab:performance_comparison_bson} presents the detailed results.

\begin{table}[ht]
  \centering
  \begin{threeparttable}
    \caption{Performance comparison between BSON and FlatCityBuf}
    \label{tab:performance_comparison_bson}
    \setlength{\tabcolsep}{6pt}
    \tiny
    \begin{tabular}{@{}l|rrr|rrr@{}}
      \toprule
      & \multicolumn{3}{c|}{\textbf{Processing Time}}
      & \multicolumn{3}{c}{\textbf{Memory Consumption}} \\
      \cmidrule(lr){2-4} \cmidrule(lr){5-7}
      \textbf{Dataset}
      & \textbf{BSON} & \textbf{FlatCityBuf} & \textbf{Ratio\tnote{a}}
      & \textbf{BSON} & \textbf{FlatCityBuf} & \textbf{Ratio\tnote{a}} \\
      \midrule
      3DBAG
      & \qty{113}{\milli\second} & \qty{6}{\milli\second} & 18.8$\times$
      & \qty{323.3}{\mega\byte} & \qty{5.4}{\mega\byte} & 59.6$\times$ \\

      3DBV
      & \qty{8.82}{\second} & \qty{120}{\milli\second} & 73.5$\times$
      & \qty{7.4}{\giga\byte} & \qty{59.0}{\mega\byte} & 129.1$\times$ \\

      Helsinki
      & \qty{9.69}{\second} & \qty{127}{\milli\second} & 76.3$\times$
      & \qty{7.4}{\giga\byte} & \qty{4.7}{\mega\byte} & 1620.9$\times$ \\

      Ingolstadt
      & \qty{81}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{323.5}{\mega\byte} & \qty{9.0}{\mega\byte} & 36.0$\times$ \\

      Montréal
      & \qty{152}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{526.8}{\mega\byte} & \qty{10.4}{\mega\byte} & 50.6$\times$ \\

      NYC
      & \qty{1.78}{\second} & \qty{42}{\milli\second} & 42.4$\times$
      & \qty{2.5}{\giga\byte} & \qty{6.6}{\mega\byte} & 385.5$\times$ \\

      Rotterdam
      & \qty{66}{\milli\second} & \qty{1}{\milli\second} & 66.0$\times$
      & \qty{340.0}{\mega\byte} & \qty{4.3}{\mega\byte} & 78.8$\times$ \\

      Vienna
      & \qty{81}{\milli\second} & \qty{1}{\milli\second} & 81.0$\times$
      & \qty{287.4}{\mega\byte} & \qty{5.7}{\mega\byte} & 50.1$\times$ \\

      Zürich
      & \qty{5.25}{\second} & \qty{149}{\milli\second} & 35.2$\times$
      & \qty{7.2}{\giga\byte} & \qty{5.9}{\mega\byte} & 1245.8$\times$ \\

      Tokyo (PLATEAU)
      & \qty{9.74}{\second} & \qty{94}{\milli\second} & 103.6$\times$
      & \qty{7.3}{\giga\byte} & \qty{14.9}{\mega\byte} & 499.5$\times$ \\

      PLATEAU\_brid
      & \qty{179}{\milli\second} & \qty{0}{\milli\second}\tnote{b} & $\infty$
      & \qty{503.6}{\mega\byte} & \qty{19.2}{\mega\byte} & 26.3$\times$ \\

      PLATEAU\_rwy
      & \qty{85}{\milli\second} & \qty{2}{\milli\second} & 42.5$\times$
      & \qty{284.1}{\mega\byte} & \qty{4.7}{\mega\byte} & 61.0$\times$ \\

      PLATEAU\_tran
      & \qty{603}{\milli\second} & \qty{14}{\milli\second} & 43.1$\times$
      & \qty{1.0}{\giga\byte} & \qty{23.0}{\mega\byte} & 46.0$\times$ \\

      PLATEAU\_tun
      & \qty{251}{\milli\second} & \qty{2}{\milli\second} & 125.5$\times$
      & \qty{618.4}{\mega\byte} & \qty{14.2}{\mega\byte} & 43.5$\times$ \\

      PLATEAU\_veg
      & \qty{2.15}{\second} & \qty{33}{\milli\second} & 65.3$\times$
      & \qty{3.8}{\giga\byte} & \qty{70.4}{\mega\byte} & 55.9$\times$ \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}[flushleft]
      \footnotesize
    \item[a] Ratio = BSON metric / FlatCityBuf metric (higher values indicate better FlatCityBuf performance)
    \item[b] Time recorded as 0 ms due to measurement precision limitations for very fast operations
    \end{tablenotes}
  \end{threeparttable}
\end{table}

\todo{Write some analysis about the results. Also take benchmark on better environment}

\subsubsection{Summary of local environment benchmark}
\label{result:benchmark_on_local_environment:summary}
To summarise the results of the local environment benchmark, we especially focus on the comparison between FlatCityBuf and CityJSONSeq since CityJSONSeq is the most standard data format of CityJSON at the moment.

\begin{itemize}
  \item Processing time: Processing time is more considarable as its pirmary objective of the research. The best case achieved 46.62$\times$ improvement (Montréal) while the worst case achieved 8.48$\times$ improvement (3DBAG). The program can save a lot of time for large datasets.
  \item Memory consumption: Memory consumption is also an important metric. The best case achieved 3.11$\times$ improvement (Tokyo) while the worst case achieved 0.62$\times$ improvement (PLATEAU\_tran).
\end{itemize}
\todo{check again}

\subsection{Benchmark over the web}
\label{result:benchmark_over_the_web}

To evaluate FlatCityBuf's performance in real-world web scenarios, we compared it with the 3DBAG API \citep{3dbag_api}. The 3DBAG API currently supports two query types: \textit{feature ID query} for retrieving CityJSONFeature by identifier (\eg, \texttt{identificatie} attribute of 3DBAG) and \textit{bounding box query} for spatial queries with configurable result limits via the \texttt{limit} parameter.

While network-based benchmarking provides more realistic performance insights, it introduces additional complexity due to variable network latency and server-side factors such as concurrent request load and server capacity. As discussed in \autoref{result:cross_platform_implementation:cloud_integration}, FlatCityBuf operates without server-side processing, requiring only static file storage. Although storage servers are technically server applications, they are often considered serverless in cloud-native environments due to their scalability and availability as managed services from cloud providers, contrasting with traditional application and database servers.

We acknowledged that comparing FlatCityBuf with the 3DBAG API is not entirely equitable due to these fundamental architectural differences. However, this comparison remains valuable as API-based access represents the current standard approach for CityJSON data consumption in web applications.

\subsubsection{Benchmark environment}
\label{result:benchmark_over_the_web:benchmark_environment}

For the web-based benchmark, we used the 3DBAG dataset. The FlatCityBuf implementation utilised a static file encoding the entire Netherlands dataset, resulting in a 70.4 GB file containing all features, attribute indices for all attributes, and spatial indexing. Data retrieval was performed using a Rust program with HTTP range requests (browser-based testing was avoided due to disk caching effects). The 3DBAG API operates on a Flask backend with PostgreSQL and PostGIS extension for database management \citep{powalka_2023}. To account for network variability and potential outliers, we collected 100 samples for each method with 10 warmup samples.

\subsubsection{Feature ID query}
\label{result:benchmark_over_the_web:feature_id_query}

Both FlatCityBuf files and the 3DBAG API database organise features according to technical implementation decisions (\eg, FlatCityBuf features are typically sorted by Hilbert curve). To ensure fair comparison by identifier, we selected 5 features distributed across different regions of the Netherlands, representing landmark or well-known buildings. The benchmark results represent the average performance across 100 samples for all 5 features.

\autoref{tab:feature_id_performance} presents the performance comparison between FlatCityBuf and the 3DBAG API for feature ID queries. Overall, FlatCityBuf demonstrates approximately 2.1$\times$ faster performance than the 3DBAG API for identifier-based feature retrieval. Performance ranged from 2.7$\times$ faster (Groningen station) to 1.5$\times$ faster (Eindhoven station).

\begin{table}[ht]
  \centering
  \caption{Feature ID query performance comparison between FlatCityBuf and 3DBAG API}
  \label{tab:feature_id_performance}
  \begin{tabular}{llccc}
    \toprule
    \textbf{Feature ID} & \textbf{Location} & \textbf{FlatCityBuf} & \textbf{3DBAG API} & \textbf{Speedup} \\
    & & \textbf{(ms)} & \textbf{(ms)} & \\
    \midrule
    NL.IMBAG.Pand.0503100000032914 & TU Delft BK building & 935.8 & 2412.5 & 2.6$\times$ \\
    NL.IMBAG.Pand.0363100012185598 & Amsterdam Central Station & 858.0 & 2106.7 & 2.5$\times$ \\
    NL.IMBAG.Pand.0014100010938997 & Groningen Station & 821.7 & 2254.8 & 2.7$\times$ \\
    NL.IMBAG.Pand.0772100000295227 & Eindhoven Station & 1378.7 & 2013.4 & 1.5$\times$ \\
    NL.IMBAG.Pand.0153100000261851 & Enschede Station & 1070.4 & 2058.8 & 1.9$\times$ \\
    \midrule
    \textbf{Average} & & \textbf{1012.9} & \textbf{2169.2} & \textbf{2.1$\times$} \\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Bounding box query}
\label{result:benchmark_over_the_web:bounding_box_query}

For spatial query performance comparison, we selected a 2km $\times$ 2km bounding box around the Delft University of Technology campus, requesting the first 10 features within the area (matching the 3DBAG API's default limit). The benchmark results represent the average of 100 samples. The bounding box coordinates were \texttt{(84000.0, 444000.0, 86000.0, 446000.0)} in the Amersfoort / RD New + NAP height (EPSG:7415) coordinate system.

FlatCityBuf demonstrated approximately 15.1$\times$ faster performance than the 3DBAG API for bounding box queries. This significant improvement over feature ID queries likely results from FlatCityBuf's Hilbert curve-based feature sorting, which enables spatially proximate features to be retrieved in batched operations.

\begin{table}[ht]
  \centering
  \caption{Bounding box query performance comparison between FlatCityBuf and 3DBAG API}
  \label{tab:bounding_box_performance}
  \begin{tabular}{lccc}
    \toprule
    \textbf{Query Type} & \textbf{FlatCityBuf} & \textbf{3DBAG API} & \textbf{Speedup} \\
    & \textbf{(ms)} & \textbf{(ms)} & \\
    \midrule
    Bounding box (2km $\times$ 2km) & 492.6 & 7420.3 & 15.1$\times$ \\
    \bottomrule
  \end{tabular}
\end{table}

Despite the architectural differences between FlatCityBuf and the 3DBAG API, FlatCityBuf demonstrated superior performance across both query patterns. Notably, FlatCityBuf does not distinguish between identifier-based and attribute-based queries, as both utilize the same underlying mechanism. Consequently, we can expect similar performance characteristics for other attribute-based queries as well. These performance results highlight FlatCityBuf's potential for web application deployment.